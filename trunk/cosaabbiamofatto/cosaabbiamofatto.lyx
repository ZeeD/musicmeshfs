#LyX 1.5.5 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{hyperref}
\end_preamble
\language italian
\inputencoding auto
\font_roman bookman
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize 12
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "basicstyle={\normalsize\ttfamily},captionpos=tb,extendedchars=true,frame=shadowbox,showstringspaces=false"
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
GNU/Linux su ARM
\end_layout

\begin_layout Author
Vito De Tullio 
\hfill

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
href{mailto:vito.detullio@gmail.com}{vito.detullio@gmail.com}
\end_layout

\end_inset


\newline
Nicola Corriero 
\hfill

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
href{mailto:ncorriero@di.uniba.it}{ncorriero@di.uniba.it}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Kernel
\end_layout

\begin_layout Standard
È stato usata la versione 2.6.25.10 del kernel vanilla (versione di default,
 non patchata) reperibile presso 
\begin_inset LatexCommand htmlurl
target "ftp://ftp.kernel.org/pub/linux/kernel/v2.6/linux-2.6.25.10.tar.bz2"

\end_inset

.
 Esistono versioni modificate da singoli per supportare questa o quell'architett
ura (in particolare è da notare la versione del kernel mantenuta da 
\begin_inset LatexCommand htmlurl
target "http://www.handhelds.org"

\end_inset

), ma non abbiamo trovato nessuna versione che già supportasse nativamente
 il nostro palmare (un 
\noun on
HTC P6300
\noun default
) e quindi abbiamo preferito utilizzare la versione di default.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Configurazione-e-compilazione"

\end_inset

Configurazione e compilazione
\end_layout

\begin_layout Standard
Dopo aver estratto il kernel, lo dobbiamo configurare per l'architettura
 
\noun on
ARM
\noun default
 utilizzando un x86, e per questo, prima del solito
\family typewriter
 make [x|menu]config
\family default
, è necessario associare alla variabile
\family typewriter
 ARCH
\family default
 il valore
\family typewriter
 arm
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,extendedchars=true,language=bash,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

$ wget ftp://ftp.kernel.org/pub/linux/kernel/v2.6/linux-2.6.25.10.tar.bz2
\end_layout

\begin_layout Standard

$ tar xjf kernel-2.6.25.10.tar.bz2
\end_layout

\begin_layout Standard

$ cd kernel-2.6.25.10
\end_layout

\begin_layout Standard

$ export ARCH=arm
\end_layout

\begin_layout Standard

$ make menuconfig
\end_layout

\end_inset


\end_layout

\begin_layout Standard
È necessario prestare attenzione soprattutto al modello di palmare su cui
 vogliamo eseguire il kernel, più altre minuzie per far funzionare i vari
 dispositivi; in particolare
\end_layout

\begin_layout Itemize
Dal menù
\noun on
 System Type \SpecialChar \menuseparator
 Arm System Type
\noun default
 scegliamo il tipo di sistema base (nel nostro caso
\noun on
 Samsung S3C2410, S3C2412, S3C2413, S3C2440, S3C2442, S3C2443
\noun default
).
\end_layout

\begin_layout Itemize
Dal menù
\noun on
 Boot options
\noun default
 impostiamo
\series bold
\noun on
 console=ttyAMA0
\series default
\noun default
 alla voce
\noun on
 Default kernel command string
\noun default
 (per poter avere in output i messaggi di comunicazione); per avere informazioni
 il prima possibile, inoltre, conviene impostare, dal menù
\noun on
 General setup
\series bold
 12
\series default
\noun default
 come valore della voce
\noun on
 Kernel log buffer size
\noun default
.
\end_layout

\begin_layout Itemize
Dal menù
\noun on
 Device Drivers
\noun default
 selezioniamo
\noun on
 MMC/SD card support
\noun default
 (per poter accedere al supporto fisico per il file system).
\end_layout

\begin_layout Standard
Dopo anche altre personalizzazioni minori, si giunge al .config finale, che,
 nel nostro caso, è abbastanza minimale: la maggior parte dei moduli, infatti,
 è stata disabilitata, tranne quelli necessari a riconoscere cpu, tastiera
 e monitor:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{_CONFIGURE_VANIGLIA_VERSATILE_2.6.25.10_no_comments}[basicstyle={\tiny\ttfamily},caption={.config finale utilizzato (le voci commentate sono state rimosse)}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Alla fine della fase di configurazione, si dovrà iniziare a compilare i
 sorgenti.
 Poiché vogliamo generare un kernel (quindi un eseguibile) per 
\noun on
ARM
\noun default
.
 Per questo motivo si rimanda alla sezione 
\begin_inset LatexCommand vref
reference "sec:Cross-compilazione"

\end_inset

 per le problematiche della cross-compilazione.
\end_layout

\begin_layout Section
Output (Image, zImage + compressore)
\end_layout

\begin_layout Standard
Terminata la fase di compilazione, verranno generati, oltre ad una serie
 di file temporanei / di supporto, i seguenti file.
\end_layout

\begin_layout Description

\family typewriter
vmlinux
\begin_inset LatexCommand nomenclature
symbol "vmlinux"
description "Eseguibile non compresso e non bootable del kernel."

\end_inset


\family default
 eseguibile
\emph on
 non compresso
\emph default
 e
\emph on
 non bootable
\emph default
 del kernel.
 Usato soprattutto per debug, come vedremo nel capitolo
\begin_inset LatexCommand vref
reference "cha:Debugger"

\end_inset

.
\end_layout

\begin_layout Description

\family typewriter
Image
\begin_inset LatexCommand nomenclature
symbol "Image"
description "Immagine del kernel effettivamente eseguita"

\end_inset


\family default
 immagine del kernel effettivamente eseguita
\end_layout

\begin_layout Description

\family typewriter
zImage
\begin_inset LatexCommand nomenclature
symbol "zImage"
description "Immagine del kernel compressa preceduta da un decompressore (obsoleta)"

\end_inset


\family default
 immagine del kernel, compressa tramite gzip e preceduta da un decompressore
 (obsoleta)
\end_layout

\begin_layout Description

\family typewriter
\begin_inset LatexCommand nomenclature
symbol "bzImage"
description "Immagine del kernel compressa ed eseguibile, ma composta da tre parti separate"

\end_inset

bzImage\InsetSpace ~

\family default
(
\begin_inset LatexCommand nomenclature
symbol "big zImage"
description "vedi bzImage"

\end_inset

big\InsetSpace ~

\family typewriter
zImage
\family default
) concatenatzione di
\family typewriter
 bootsect.o
\family default
 +
\family typewriter
 setup.o
\family default
 +
\family typewriter
 misc.o
\family default
 +
\family typewriter
 piggy.o
\family default
.
\begin_inset LatexCommand citep
key "vmlinuz_definition,vmlinux_zimage"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Anatomy-of-bzimage.png
	lyxscale 50
	width 80col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Anatomia di bzImage (da 
\begin_inset LatexCommand htmlurl
target "en.wikipedia.org"

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Section
Avvio
\end_layout

\begin_layout Standard
Una volta che il bootloader ha caricato il kernel in memoria e l'ha eseguito,
 vi è la fase di bootstrap
\begin_inset LatexCommand nomenclature
symbol "bootstrap"
description "Letteralmente la fascetta di cuoio cucita sul bordo posteriore degli stivali per aiutarsi a calzarli, fa riferimento alla leggenda del Barone di Münchhausen e alla sua capacità di sollevarsi in aria \"tirandosi per gli stivali\".\\\\Indica la fase di avvio di un pc"

\end_inset

 che, nell'architettura 
\noun on
ARM
\noun default
, è implementata per la maggior parte in assembly.
\end_layout

\begin_layout Subsection
Sorgenti
\end_layout

\begin_layout Standard
Il codice che si prende carico del boot del sistema è presente nelle directory
 
\noun on
arch/arm/boot/compressed
\noun default
 e 
\noun on
arch/arm/kernel
\noun default
 ove sono presenti, oltre a del codice d'appoggio per comprimere e decomprimere
 l'eseguibile, anche una serie di file 
\noun on
.S
\noun default
 (scritti in assembly per 
\noun on
ARM
\noun default
) tra i quali sono degni di nota i 2 file 
\noun on
head.S
\noun default
.
\end_layout

\begin_layout Standard

\noun on
arch/arm/kernel/head.S
\noun default
, in particolare, contiene la parte di codice che, di fatto, è il punto
 di partenza del kernel.
 In effetti questo codice, compilato, corrisponde alle prime istruzioni
 presenti in nel file 
\noun on
Image
\noun default
 già descritto;
\end_layout

\begin_layout Standard
Ovviamente nel caso si decida di usare i file 
\noun on
zImage
\noun default
 e 
\noun on
bzImage
\noun default
, questo codice sarà quello invocato al termine della decompressione del
 kernel stesso.
\end_layout

\begin_layout Standard
Ciò si evince anche dai commenti presenti nel file, come si può vedere:
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,firstnumber=59,language=C,numbers=left,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * Kernel startup entry point.
\end_layout

\begin_layout Standard

 * ---------------------------
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * This is normally called from the decompressor code.
 The requirements
\end_layout

\begin_layout Standard

 * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
\end_layout

\begin_layout Standard

 * r1 = machine nr, r2 = atags pointer.
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * This code is mostly position independent, so if you link the kernel at
\end_layout

\begin_layout Standard

 * 0xc0008000, you call this at __pa(0xc0008000).
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * See linux/arch/arm/tools/mach-types for the complete list of machine
\end_layout

\begin_layout Standard

 * numbers for r1.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In particolare, viene fatto riferimento al file 
\noun on
arch/arm/tools/mach-types
\noun default
: questi altro non è che un 
\begin_inset Quotes eld
\end_inset

database
\begin_inset Quotes erd
\end_inset

 in cui si associa ad ogni modello supportato dal kernel che implementa
 le specifiche dell'
\noun on
ARM
\noun default
, una serie di codici univoci usati per poter generare delle guardie per
 implementare codice dipendente da macchina a macchina.
 Questo file è mantenuto dal 
\begin_inset Quotes eld
\end_inset

The ARM Linux Project
\begin_inset Quotes erd
\end_inset


\begin_inset LatexCommand citep
key "mach_types_home_page"

\end_inset

, che assicura l'univocità degli identificatori usati per i vari palmari.
\end_layout

\begin_layout Standard
In aggiunta a questo file vi è uno script awk (
\noun on
arch/arm/tools/gen-mach-types
\noun default
) capace di trasformare questo file di configurazione nel file 
\noun on
include/asm-arm/mach-types.h
\noun default
, pieno di macro usate in fase di compilazione per abilitare o meno il codice
 specifico della macchina target.
\end_layout

\begin_layout Subsection
Decompressione
\end_layout

\begin_layout Standard
Le prime istruzioni eseguite all'avvio di una zImage sono quelle relative
 alla decompressione del kernel.
\end_layout

\begin_layout Standard
Il codice relativo alla decompressione è scritto in Assembly e si trova
 all'interno del file 
\noun on
arch/arm/boot/compressed/head.s
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,language=C"
inline false
status open

\begin_layout Standard

...
\end_layout

\begin_layout Standard

               .section ".start", #alloc, #execinstr
\end_layout

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * sort out different calling conventions
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

                .align
\end_layout

\begin_layout Standard

start:
\end_layout

\begin_layout Standard

                .type   start,#function
\end_layout

\begin_layout Standard

                .rept   8
\end_layout

\begin_layout Standard

                mov     r0, r0
\end_layout

\begin_layout Standard

                .endr
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                b       1f
\end_layout

\begin_layout Standard

                .word   0x016f2818              @ Magic numbers to help the
 loader
\end_layout

\begin_layout Standard

                .word   start                   @ absolute load/run zImage
 address
\end_layout

\begin_layout Standard

                .word   _edata                  @ zImage end address
\end_layout

\begin_layout Standard

1:              mov     r7, r1                  @ save architecture ID
\end_layout

\begin_layout Standard

                mov     r8, #0                  @ save r0
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

#ifndef __ARM_ARCH_2__
\end_layout

\begin_layout Standard

                /*
\end_layout

\begin_layout Standard

                 * Booting from Angel - need to enter SVC mode and disable
\end_layout

\begin_layout Standard

                 * FIQs/IRQs (numeric definitions from angel arm.h source).
\end_layout

\begin_layout Standard

                 * We only do this if we were in user mode on entry.
\end_layout

\begin_layout Standard

                 */
\end_layout

\begin_layout Standard

                mrs     r2, cpsr                @ get current mode
\end_layout

\begin_layout Standard

                tst     r2, #3                  @ not user?
\end_layout

\begin_layout Standard

                bne     not_angel
\end_layout

\begin_layout Standard

                mov     r0, #0x17               @ angel_SWIreason_EnterSVC
\end_layout

\begin_layout Standard

                swi     0x123456                @ angel_SWI_ARM
\end_layout

\begin_layout Standard

not_angel:
\end_layout

\begin_layout Standard

                mrs     r2, cpsr                @ turn off interrupts to
\end_layout

\begin_layout Standard

                orr     r2, r2, #0xc0           @ prevent angel from running
\end_layout

\begin_layout Standard

                msr     cpsr_c, r2
\end_layout

\begin_layout Standard

#else
\end_layout

\begin_layout Standard

                teqp    pc, #0x0c000003         @ turn off interrupts
\end_layout

\begin_layout Standard

#endif
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                /*
\end_layout

\begin_layout Standard

                 * Note that some cache flushing and other stuff may
\end_layout

\begin_layout Standard

                 * be needed here - is there an Angel SWI call for this?
\end_layout

\begin_layout Standard

                 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                /*
\end_layout

\begin_layout Standard

                 * some architecture specific code can be inserted
\end_layout

\begin_layout Standard

                 * by the linker here, but it should preserve r7 and r8.
\end_layout

\begin_layout Standard

                 */
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                .text
\end_layout

\begin_layout Standard

                adr     r0, LC0
\end_layout

\begin_layout Standard

                ldmia   r0, {r1, r2, r3, r4, r5, r6, ip, sp}
\end_layout

\begin_layout Standard

                subs    r0, r0, r1              @ calculate the delta offset
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                                                @ if delta is zero, we're
\end_layout

\begin_layout Standard

                beq     not_relocated           @ running at the address
 we
\end_layout

\begin_layout Standard

                                                @ were linked at.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                /*
\end_layout

\begin_layout Standard

                 * We're running at a different address.
  We need to fix
\end_layout

\begin_layout Standard

                 * up various pointers:
\end_layout

\begin_layout Standard

                 *   r5 - zImage base address
\end_layout

\begin_layout Standard

                 *   r6 - GOT start
\end_layout

\begin_layout Standard

                 *   ip - GOT end
\end_layout

\begin_layout Standard

                 */
\end_layout

\begin_layout Standard

                add     r5, r5, r0
\end_layout

\begin_layout Standard

                add     r6, r6, r0
\end_layout

\begin_layout Standard

                add     ip, ip, r0
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

#ifndef CONFIG_ZBOOT_ROM
\end_layout

\begin_layout Standard

                /*
\end_layout

\begin_layout Standard

                 * If we're running fully PIC === CONFIG_ZBOOT_ROM = n,
\end_layout

\begin_layout Standard

                 * we need to fix up pointers into the BSS region.
\end_layout

\begin_layout Standard

                 *   r2 - BSS start
\end_layout

\begin_layout Standard

                 *   r3 - BSS end
\end_layout

\begin_layout Standard

                 *   sp - stack pointer
\end_layout

\begin_layout Standard

                 */
\end_layout

\begin_layout Standard

                add     r2, r2, r0
\end_layout

\begin_layout Standard

                add     r3, r3, r0
\end_layout

\begin_layout Standard

                add     sp, sp, r0
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                /*
\end_layout

\begin_layout Standard

                 * Relocate all entries in the GOT table.
\end_layout

\begin_layout Standard

                 */
\end_layout

\begin_layout Standard

1:              ldr     r1, [r6, #0]            @ relocate entries in the
 GOT
\end_layout

\begin_layout Standard

                add     r1, r1, r0              @ table.
  This fixes up the
\end_layout

\begin_layout Standard

                str     r1, [r6], #4            @ C references.
\end_layout

\begin_layout Standard

                cmp     r6, ip
\end_layout

\begin_layout Standard

                blo     1b
\end_layout

\begin_layout Standard

#else
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                /*
\end_layout

\begin_layout Standard

                 * Relocate entries in the GOT table.
  We only relocate
\end_layout

\begin_layout Standard

                 * the entries that are outside the (relocated) BSS region.
\end_layout

\begin_layout Standard

                 */
\end_layout

\begin_layout Standard

1:              ldr     r1, [r6, #0]            @ relocate entries in the
 GOT
\end_layout

\begin_layout Standard

                cmp     r1, r2                  @ entry < bss_start ||
\end_layout

\begin_layout Standard

                cmphs   r3, r1                  @ _end < entry
\end_layout

\begin_layout Standard

                addlo   r1, r1, r0              @ table.
  This fixes up the
\end_layout

\begin_layout Standard

                str     r1, [r6], #4            @ C references.
\end_layout

\begin_layout Standard

                cmp     r6, ip
\end_layout

\begin_layout Standard

                blo     1b
\end_layout

\begin_layout Standard

#endif
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

not_relocated:  mov     r0, #0
\end_layout

\begin_layout Standard

1:              str     r0, [r2], #4            @ clear bss
\end_layout

\begin_layout Standard

                str     r0, [r2], #4
\end_layout

\begin_layout Standard

                str     r0, [r2], #4
\end_layout

\begin_layout Standard

                str     r0, [r2], #4
\end_layout

\begin_layout Standard

                cmp     r2, r3
\end_layout

\begin_layout Standard

                blo     1b
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                /*
\end_layout

\begin_layout Standard

                 * The C runtime environment should now be setup
\end_layout

\begin_layout Standard

                 * sufficiently.
  Turn the cache on, set up some
\end_layout

\begin_layout Standard

                 * pointers, and start decompressing.
\end_layout

\begin_layout Standard

                 */
\end_layout

\begin_layout Standard

                bl      cache_on
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                mov     r1, sp                  @ malloc space above stack
\end_layout

\begin_layout Standard

                add     r2, sp, #0x10000        @ 64k max
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * Check to see if we will overwrite ourselves.
\end_layout

\begin_layout Standard

 *   r4 = final kernel address
\end_layout

\begin_layout Standard

 *   r5 = start of this image
\end_layout

\begin_layout Standard

 *   r2 = end of malloc space (and therefore this image)
\end_layout

\begin_layout Standard

 * We basically want:
\end_layout

\begin_layout Standard

 *   r4 >= r2 -> OK
\end_layout

\begin_layout Standard

 *   r4 + image length <= r5 -> OK
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

                cmp     r4, r2
\end_layout

\begin_layout Standard

                bhs     wont_overwrite
\end_layout

\begin_layout Standard

                add     r0, r4, #4096*1024      @ 4MB largest kernel size
\end_layout

\begin_layout Standard

                cmp     r0, r5
\end_layout

\begin_layout Standard

                bls     wont_overwrite
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                mov     r5, r2                  @ decompress after malloc
 space
\end_layout

\begin_layout Standard

                mov     r0, r5
\end_layout

\begin_layout Standard

                mov     r3, r7
\end_layout

\begin_layout Standard

                bl      decompress_kernel
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                add     r0, r0, #127
\end_layout

\begin_layout Standard

                bic     r0, r0, #127            @ align the kernel length
\end_layout

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * r0     = decompressed kernel length
\end_layout

\begin_layout Standard

 * r1-r3  = unused
\end_layout

\begin_layout Standard

 * r4     = kernel execution address
\end_layout

\begin_layout Standard

 * r5     = decompressed kernel start
\end_layout

\begin_layout Standard

 * r6     = processor ID
\end_layout

\begin_layout Standard

 * r7     = architecture ID
\end_layout

\begin_layout Standard

 * r8-r14 = unused
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

                add     r1, r5, r0              @ end of decompressed kernel
\end_layout

\begin_layout Standard

                adr     r2, reloc_start
\end_layout

\begin_layout Standard

                ldr     r3, LC1
\end_layout

\begin_layout Standard

                add     r3, r2, r3
\end_layout

\begin_layout Standard

1:              ldmia   r2!, {r8 - r13}         @ copy relocation code
\end_layout

\begin_layout Standard

                stmia   r1!, {r8 - r13}
\end_layout

\begin_layout Standard

                ldmia   r2!, {r8 - r13}
\end_layout

\begin_layout Standard

                stmia   r1!, {r8 - r13}
\end_layout

\begin_layout Standard

                cmp     r2, r3
\end_layout

\begin_layout Standard

                blo     1b
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                bl      cache_clean_flush
\end_layout

\begin_layout Standard

                add     pc, r5, r0              @ call relocation code
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * We're not in danger of overwriting ourselves.
  Do this the simple way.
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * r4     = kernel execution address
\end_layout

\begin_layout Standard

 * r7     = architecture ID
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

wont_overwrite: mov     r0, r4
\end_layout

\begin_layout Standard

                mov     r3, r7
\end_layout

\begin_layout Standard

                bl      decompress_kernel
\end_layout

\begin_layout Standard

                b       call_kernel
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

                .type   LC0, #object
\end_layout

\begin_layout Standard

LC0:            .word   LC0                     @ r1
\end_layout

\begin_layout Standard

                .word   __bss_start             @ r2
\end_layout

\begin_layout Standard

                .word   _end                    @ r3
\end_layout

\begin_layout Standard

                .word   _load_addr              @ r4
\end_layout

\begin_layout Standard

                .word   _start                  @ r5
\end_layout

\begin_layout Standard

                .word   _got_start              @ r6
\end_layout

\begin_layout Standard

                .word   _got_end                @ ip
\end_layout

\begin_layout Standard

                .word   user_stack+4096         @ sp
\end_layout

\begin_layout Standard

LC1:            .word   reloc_end - reloc_start
\end_layout

\begin_layout Standard

                .size   LC0, .
 - LC0
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove la funzione 
\emph on
start_kernel
\emph default
 è presente nel file 
\noun on
arch/arm/boot/compressed/misc.c
\noun default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Standard

...
\end_layout

\begin_layout Standard

#ifndef STANDALONE_DEBUG
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

ulg
\end_layout

\begin_layout Standard

decompress_kernel(ulg output_start, ulg free_mem_ptr_p, ulg free_mem_ptr_end_p,
\end_layout

\begin_layout Standard

                  int arch_id)
\end_layout

\begin_layout Standard

{
\end_layout

\begin_layout Standard

        output_data             = (uch *)output_start;  /* Points to kernel
 start */
\end_layout

\begin_layout Standard

        free_mem_ptr            = free_mem_ptr_p;
\end_layout

\begin_layout Standard

        free_mem_ptr_end        = free_mem_ptr_end_p;
\end_layout

\begin_layout Standard

        __machine_arch_type     = arch_id;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        arch_decomp_setup();
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        makecrc();
\end_layout

\begin_layout Standard

        puts("Uncompressing Linux...");
\end_layout

\begin_layout Standard

        gunzip();
\end_layout

\begin_layout Standard

        puts(" done, booting the kernel.
\backslash
n");
\end_layout

\begin_layout Standard

        return output_ptr;
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

#else
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

char output_buffer[1500*1024];
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

int main()
\end_layout

\begin_layout Standard

{
\end_layout

\begin_layout Standard

        output_data = output_buffer;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        makecrc();
\end_layout

\begin_layout Standard

        puts("Uncompressing Linux...");
\end_layout

\begin_layout Standard

        gunzip();
\end_layout

\begin_layout Standard

        puts("done.
\backslash
n");
\end_layout

\begin_layout Standard

        return 0;
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

#endif
\end_layout

\begin_layout Standard

        
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Boot
\end_layout

\begin_layout Standard
Tornando alla sequenza di boot, analizziamo un attimo le prime istruzioni
 presenti in
\noun on
 arch/arm/kernel/head.S
\noun default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,firstnumber=77,language=C,numbers=left,showstringspaces=false"
inline false
status open

\begin_layout Standard

        .section ".text.head", "ax"
\end_layout

\begin_layout Standard

        .type   stext, %function
\end_layout

\begin_layout Standard

ENTRY(stext)
\end_layout

\begin_layout Standard

        msr     cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode
\end_layout

\begin_layout Standard

                                                @ and irqs disabled
\end_layout

\begin_layout Standard

        mrc     p15, 0, r9, c0, c0              @ get processor id
\end_layout

\begin_layout Standard

        bl      __lookup_processor_type         @ r5=procinfo r9=cpuid
\end_layout

\begin_layout Standard

        movs    r10, r5                         @ invalid processor (r5=0)?
\end_layout

\begin_layout Standard

        beq     __error_p                       @ yes, error 'p'
\end_layout

\begin_layout Standard

        bl      __lookup_machine_type           @ r5=machinfo
\end_layout

\begin_layout Standard

        movs    r8, r5                          @ invalid machine (r5=0)?
\end_layout

\begin_layout Standard

        beq     __error_a                       @ yes, error 'a'
\end_layout

\begin_layout Standard

        bl      __vet_atags
\end_layout

\begin_layout Standard

        bl      __create_page_tables
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        /*
\end_layout

\begin_layout Standard

         * The following calls CPU specific code in a position independent
\end_layout

\begin_layout Standard

         * manner.
  See arch/arm/mm/proc-*.S for details.
  r10 = base of
\end_layout

\begin_layout Standard

         * xxx_proc_info structure selected by __lookup_machine_type
\end_layout

\begin_layout Standard

         * above.
  On return, the CPU will be ready for the MMU to be
\end_layout

\begin_layout Standard

         * turned on, and r0 will hold the CPU control register value.
\end_layout

\begin_layout Standard

        */
\end_layout

\begin_layout Standard

        ldr     r13, __switch_data              @ address to jump to after
\end_layout

\begin_layout Standard

                                                @ mmu has been enabled
\end_layout

\begin_layout Standard

        adr     lr, __enable_mmu                @ return (PIC) address
\end_layout

\begin_layout Standard

        add     pc, r10, #PROCINFO_INITFUNC
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All'inizio degni di nota sono soprattutto i controlli effettuati dal kernel
 sulla possibilità di supportare processore e macchina.
\end_layout

\begin_layout Standard
In caso d'errore vengono invocate delle funzioni per avvisare l'utente -
 e terminare l'esecuzione del programma.
 Altrimenti vengono 
\begin_inset Quotes eld
\end_inset

salvati
\begin_inset Quotes erd
\end_inset

 nel registro 10 il processore e nel registro 8 il tipo di macchina.
\end_layout

\begin_layout Standard
Una volta superati i controlli l'esecuzione continua con il codice specifico
 della cpu.
 Ma vengono salvate alcune funzioni da eseguire in seguito.
\end_layout

\begin_layout Standard
Nelle ultime tre righe, infatti, si istruisce il programma a salvare nel
 registro 13 il codice di __switch_data e a salvare nel 
\begin_inset Quotes eld
\end_inset

last register
\begin_inset Quotes erd
\end_inset

 (lr) il codice per abilitare l'MMU
\begin_inset LatexCommand nomenclature
symbol "MMU"
description "Memory Management Unit"

\end_inset

.
 Questi dovrà essere eseguito dopo il codice specifico della macchina: l'ultima
 riga, infatti, altro non fa che scrivere sul program counter (pc) la somma
 del registro 10 (indirizzo di memoria che contiene le informazioni sulla
 cpu riconosciuta) col valore di PROCINFO_INITFUNC, definito in 
\noun on
arch/arm/kernel/asm-offsets.c 
\noun default
come
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily},breaklines=true,extendedchars=true,language=C,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

DEFINE(PROCINFO_INITFUNC, offsetof(struct proc_info_list, __cpu_flush));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove 
\noun on
proc_info_list
\noun default
 altro non è che la struttura della variabile contenente le informazioni
 del processore, e __cpu_flush è un suo campo.
 Nel nostro caso verrà eseguito il codice presente nel file arch/arm/mm/proc-arm
926.S.
 (è la cpu per la quale stiamo compilando il kernel)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,firstnumber=471,language=C,numbers=left,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

        .type   __arm926_proc_info,#object
\end_layout

\begin_layout Standard

__arm926_proc_info:
\end_layout

\begin_layout Standard

        .long   0x41069260                      @ ARM926EJ-S (v5TEJ)
\end_layout

\begin_layout Standard

        .long   0xff0ffff0
\end_layout

\begin_layout Standard

        .long   PMD_TYPE_SECT | 
\backslash

\end_layout

\begin_layout Standard

                PMD_SECT_BUFFERABLE | 
\backslash

\end_layout

\begin_layout Standard

                PMD_SECT_CACHEABLE | 
\backslash

\end_layout

\begin_layout Standard

                PMD_BIT4 | 
\backslash

\end_layout

\begin_layout Standard

                PMD_SECT_AP_WRITE | 
\backslash

\end_layout

\begin_layout Standard

                PMD_SECT_AP_READ
\end_layout

\begin_layout Standard

        .long   PMD_TYPE_SECT | 
\backslash

\end_layout

\begin_layout Standard

                PMD_BIT4 | 
\backslash

\end_layout

\begin_layout Standard

                PMD_SECT_AP_WRITE | 
\backslash

\end_layout

\begin_layout Standard

                PMD_SECT_AP_READ
\end_layout

\begin_layout Standard

        b       __arm926_setup
\end_layout

\begin_layout Standard

        .long   cpu_arch_name
\end_layout

\begin_layout Standard

        .long   cpu_elf_name
\end_layout

\begin_layout Standard

        .long   HWCAP_SWP|HWCAP_HALF|HWCAP_THUMB|HWCAP_FAST_MULT|HWCAP_EDSP|HWCAP
_JAVA
\end_layout

\begin_layout Standard

        .long   cpu_arm926_name
\end_layout

\begin_layout Standard

        .long   arm926_processor_functions
\end_layout

\begin_layout Standard

        .long   v4wbi_tlb_fns
\end_layout

\begin_layout Standard

        .long   v4wb_user_fns
\end_layout

\begin_layout Standard

        .long   arm926_cache_fns
\end_layout

\begin_layout Standard

        .size   __arm926_proc_info, .
 - __arm926_proc_info
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quindi in pratica andremo ad eseguire il codice presente nel quinto campo
 della struttura, cioé __arm926_setup, definita nello stesso file
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,firstnumber=395,language=C,numbers=left,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

        .type   __arm926_setup, #function
\end_layout

\begin_layout Standard

__arm926_setup:
\end_layout

\begin_layout Standard

        mov     r0, #0
\end_layout

\begin_layout Standard

        mcr     p15, 0, r0, c7, c7              @ invalidate I,D caches
 on v4
\end_layout

\begin_layout Standard

        mcr     p15, 0, r0, c7, c10, 4          @ drain write buffer on
 v4
\end_layout

\begin_layout Standard

#ifdef CONFIG_MMU
\end_layout

\begin_layout Standard

        mcr     p15, 0, r0, c8, c7              @ invalidate I,D TLBs on
 v4
\end_layout

\begin_layout Standard

#endif
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
\end_layout

\begin_layout Standard

        mov     r0, #4                          @ disable write-back on
 caches explicitly
\end_layout

\begin_layout Standard

        mcr     p15, 7, r0, c15, c0, 0
\end_layout

\begin_layout Standard

#endif
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        adr     r5, arm926_crval
\end_layout

\begin_layout Standard

        ldmia   r5, {r5, r6}
\end_layout

\begin_layout Standard

        mrc     p15, 0, r0, c1, c0              @ get control register v4
\end_layout

\begin_layout Standard

        bic     r0, r0, r5
\end_layout

\begin_layout Standard

        orr     r0, r0, r6
\end_layout

\begin_layout Standard

#ifdef CONFIG_CPU_CACHE_ROUND_ROBIN
\end_layout

\begin_layout Standard

        orr     r0, r0, #0x4000                 @ .1..
 ....
 ....
 ....
\end_layout

\begin_layout Standard

#endif
\end_layout

\begin_layout Standard

        mov     pc, lr
\end_layout

\begin_layout Standard

        .size   __arm926_setup, .
 - __arm926_setup
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A parte il codice specifico, è da notare come termini scrivendo sul program
 counter il valore del last register, cioè l'indirizzo di __enable_mmu.
 Essa è definita in head.S.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,firstnumber=149,language=C,numbers=left,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * Setup common bits before finally enabling the MMU.
  Essentially
\end_layout

\begin_layout Standard

 * this is just loading the page table pointer and domain access
\end_layout

\begin_layout Standard

 * registers.
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

        .type   __enable_mmu, %function
\end_layout

\begin_layout Standard

__enable_mmu:
\end_layout

\begin_layout Standard

#ifdef CONFIG_ALIGNMENT_TRAP
\end_layout

\begin_layout Standard

        orr     r0, r0, #CR_A
\end_layout

\begin_layout Standard

#else
\end_layout

\begin_layout Standard

        bic     r0, r0, #CR_A
\end_layout

\begin_layout Standard

#endif
\end_layout

\begin_layout Standard

#ifdef CONFIG_CPU_DCACHE_DISABLE
\end_layout

\begin_layout Standard

        bic     r0, r0, #CR_C
\end_layout

\begin_layout Standard

#endif
\end_layout

\begin_layout Standard

#ifdef CONFIG_CPU_BPREDICT_DISABLE
\end_layout

\begin_layout Standard

        bic     r0, r0, #CR_Z
\end_layout

\begin_layout Standard

#endif
\end_layout

\begin_layout Standard

#ifdef CONFIG_CPU_ICACHE_DISABLE
\end_layout

\begin_layout Standard

        bic     r0, r0, #CR_I
\end_layout

\begin_layout Standard

#endif
\end_layout

\begin_layout Standard

        mov     r5, #(domain_val(DOMAIN_USER, DOMAIN_MANAGER) | 
\backslash

\end_layout

\begin_layout Standard

                      domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) | 
\backslash

\end_layout

\begin_layout Standard

                      domain_val(DOMAIN_TABLE, DOMAIN_MANAGER) | 
\backslash

\end_layout

\begin_layout Standard

                      domain_val(DOMAIN_IO, DOMAIN_CLIENT))
\end_layout

\begin_layout Standard

        mcr     p15, 0, r5, c3, c0, 0           @ load domain access register
\end_layout

\begin_layout Standard

        mcr     p15, 0, r4, c2, c0, 0           @ load page table pointer
\end_layout

\begin_layout Standard

        b       __turn_mmu_on
\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'ultima riga invoca la funzione __turn_mmu_on, definita subito dopo.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,firstnumber=178,language=C,numbers=left,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * Enable the MMU.
  This completely changes the structure of the visible
\end_layout

\begin_layout Standard

 * memory space.
  You will not be able to trace execution through this.
\end_layout

\begin_layout Standard

 * If you have an enquiry about this, *please* check the linux-arm-kernel
\end_layout

\begin_layout Standard

 * mailing list archives BEFORE sending another post to the list.
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 *  r0  = cp#15 control register
\end_layout

\begin_layout Standard

 *  r13 = *virtual* address to jump to upon completion
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * other registers depend on the function called upon completion
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

        .align  5
\end_layout

\begin_layout Standard

        .type   __turn_mmu_on, %function
\end_layout

\begin_layout Standard

__turn_mmu_on:
\end_layout

\begin_layout Standard

        mov     r0, r0
\end_layout

\begin_layout Standard

        mcr     p15, 0, r0, c1, c0, 0           @ write control reg
\end_layout

\begin_layout Standard

        mrc     p15, 0, r3, c0, c0, 0           @ read id reg
\end_layout

\begin_layout Standard

        mov     r3, r3
\end_layout

\begin_layout Standard

        mov     r3, r3
\end_layout

\begin_layout Standard

        mov     pc, r13
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al termine della funzione, viene modificato il program counter per eseguire
 il contenuto del registro 13, contenente l'oggetto __switch_data.
 Questo è definito nel file 
\noun on
arch/arm/kernel/head-common.S
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,firstnumber=17,language=C,numbers=left,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

        .type   __switch_data, %object
\end_layout

\begin_layout Standard

__switch_data:
\end_layout

\begin_layout Standard

        .long   __mmap_switched
\end_layout

\begin_layout Standard

        .long   __data_loc                      @ r4
\end_layout

\begin_layout Standard

        .long   __data_start                    @ r5
\end_layout

\begin_layout Standard

        .long   __bss_start                     @ r6
\end_layout

\begin_layout Standard

        .long   _end                            @ r7
\end_layout

\begin_layout Standard

        .long   processor_id                    @ r4
\end_layout

\begin_layout Standard

        .long   __machine_arch_type             @ r5
\end_layout

\begin_layout Standard

        .long   __atags_pointer                 @ r6
\end_layout

\begin_layout Standard

        .long   cr_alignment                    @ r7
\end_layout

\begin_layout Standard

        .long   init_thread_union + THREAD_START_SP @ sp
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * The following fragment of code is executed with the MMU on in MMU mode,
\end_layout

\begin_layout Standard

 * and uses absolute addresses; this is not position independent.
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 *  r0  = cp#15 control register
\end_layout

\begin_layout Standard

 *  r1  = machine ID
\end_layout

\begin_layout Standard

 *  r2  = atags pointer
\end_layout

\begin_layout Standard

 *  r9  = processor ID
\end_layout

\begin_layout Standard

 */
\end_layout

\begin_layout Standard

        .type   __mmap_switched, %function
\end_layout

\begin_layout Standard

__mmap_switched:
\end_layout

\begin_layout Standard

        adr     r3, __switch_data + 4
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        ldmia   r3!, {r4, r5, r6, r7}
\end_layout

\begin_layout Standard

        cmp     r4, r5                          @ Copy data segment if needed
\end_layout

\begin_layout Standard

1:      cmpne   r5, r6
\end_layout

\begin_layout Standard

        ldrne   fp, [r4], #4
\end_layout

\begin_layout Standard

        strne   fp, [r5], #4
\end_layout

\begin_layout Standard

        bne     1b
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        mov     fp, #0                          @ Clear BSS (and zero fp)
\end_layout

\begin_layout Standard

1:      cmp     r6, r7
\end_layout

\begin_layout Standard

        strcc   fp, [r6],#4
\end_layout

\begin_layout Standard

        bcc     1b
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        ldmia   r3, {r4, r5, r6, r7, sp}
\end_layout

\begin_layout Standard

        str     r9, [r4]                        @ Save processor ID
\end_layout

\begin_layout Standard

        str     r1, [r5]                        @ Save machine type
\end_layout

\begin_layout Standard

        str     r2, [r6]                        @ Save atags pointer
\end_layout

\begin_layout Standard

        bic     r4, r0, #CR_A                   @ Clear 'A' bit
\end_layout

\begin_layout Standard

        stmia   r7, {r0, r4}                    @ Save control register
 values
\end_layout

\begin_layout Standard

        b       start_kernel
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo campo dell'oggetto __switch_data è la funzione __mmap_switched
 che, eseguita, termina invocando start_kernel, la funzione 
\begin_inset Quotes eld
\end_inset

ad alto livello
\begin_inset Quotes erd
\end_inset

 implementata in C nel file init/main.c.
\end_layout

\begin_layout Chapter
Compilatore
\end_layout

\begin_layout Standard
L'altra componente necessaria per compilare un kernel è, ovviamente, un
 compilatore :)
\end_layout

\begin_layout Section
Quale
\end_layout

\begin_layout Standard
Per compilare il kernel linux è necessario usare il gcc, a causa delle varie
 estensioni del compilatore utilizzate dai 
\emph on
kernel hackers
\emph default
.
 
\end_layout

\begin_layout Standard
Sulla versione da utilizzare non ci sono preferenze, ma, in genere, più
 nuovo è, meglio è.
\end_layout

\begin_layout Standard
In effetti ci potrebbero essere problemi in caso di versioni del kernel
 e del compilatore particolarmente differenti tra di loro, a causa dell'uso
 (e spesso dell'abuso) che viene fatto delle varie estensioni 
\emph on
non standard
\emph default
.
 
\end_layout

\begin_layout Standard
Nel nostro caso sono state usate varie versioni, principalmente 4.2.3 e 3.4.1,
 senza riscontrare particolari problemi.
\end_layout

\begin_layout Section
\begin_inset LatexCommand label
name "sec:Cross-compilazione"

\end_inset

Cross-compilazione
\end_layout

\begin_layout Standard
Per compilare un kernel per 
\noun on
ARM
\noun default
 ci sono le seguenti opzioni:
\end_layout

\begin_layout Enumerate
Avere un sistema operativo + compilatore 
\noun on
C
\noun default
 su architettura 
\noun on
ARM
\noun default
 (e parecchio tempo, data la potenza di questi dispositivi).
\end_layout

\begin_layout Enumerate
\begin_inset LatexCommand label
name "enu:cross-compilare"

\end_inset

Avere un sistema operativo + compilatore 
\noun on
C
\noun default
 su architettura x86 + istruire il compilatore 
\noun on
C
\noun default
 a generare eseguibili per architettura 
\noun on
ARM
\noun default
.
\end_layout

\begin_layout Standard
Si è scelto di approcciarsi al problema tramite la soluzione 
\begin_inset LatexCommand ref
reference "enu:cross-compilare"

\end_inset

.
 D'ora innanzi, quindi, si dirà
\end_layout

\begin_layout Description

\noun on
host
\begin_inset LatexCommand nomenclature
symbol "host"
description "In ambiente di emulazione, la macchina reale che ospita l'emulatore.\\\\In ambiente di cross-compilazione, la macchina che ospita il compilatore.\\\\Vedi: target"

\end_inset


\noun default
 la macchina x86 su cui sono presenti compilatore e sorgenti
\end_layout

\begin_layout Description

\noun on
target
\begin_inset LatexCommand nomenclature
symbol "target"
description "In ambiente di emulazione, la macchina virtuale generata dall'emulatore.\\\\In ambiente di cross-compilazione, la macchina su cui verranno utilizzati i programmi compilati.\\\\Vedi: host"

\end_inset


\noun default
 la macchina ARM su cui si utilizzerà effettivamente il kernel compilato
\end_layout

\begin_layout Standard
Ciò comporta una serie di vantaggi:
\end_layout

\begin_layout Itemize
Si può utilizzare come 
\noun on
host
\noun default
 un sistema linux già funzionante (nel nostro caso, sono stati utilizzati
 una debian Lenny e una OpenSuse 10.3)
\end_layout

\begin_layout Itemize
La capacità di calcolo di una macchina
\noun on
 target
\noun default
 è generalmente limitata, mentre le macchine
\noun on
 host
\noun default
 sono molto più potenti (minimizzando i tempi morti in attesa del termine
 della compilazione)
\end_layout

\begin_layout Itemize
\begin_inset Note Shaded
status open

\begin_layout Standard
TROVARE ALTRI VANTAGGI??
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ovviamente vi è la difficoltà di avere un compilatore 
\noun on
C
\noun default
 in grado di generare eseguibili per la macchina
\noun on
 target
\noun default
.
 Per fortuna questo è offerto da gcc.
 Per abilitare questa
\emph on
 feature
\emph default
, però, è necessario impostare una opzione in fase di compilazione.
\end_layout

\begin_layout Standard
Nel nostro caso si è evitato di ri-compilare il compilatore, ed è stata
 utilizzata una versione pre-compilata di gcc da 
\begin_inset LatexCommand htmlurl
name "handhelds.org"
target "http://www.handhelds.org/download/projects/toolchain/"

\end_inset


\begin_inset LatexCommand citep
key "handhelds_toolchain"

\end_inset

.
\end_layout

\begin_layout Standard
Tuttavia è necessario istruire il kernel del fatto che vogliamo compilare
 i sorgenti (già configurati) con un compilatore diverso (ed un diverso
 linker, assembler, ecc).
\end_layout

\begin_layout Standard
Per questo viene in aiuto la variabile d'ambiente 
\noun on
CROSS_COMPILER
\noun default
, che istruisce il make su dove andare a cercare la 
\emph on
toolchain
\begin_inset LatexCommand nomenclature
symbol "toolchain"
description "Insieme di tutti gli strumenti (tra gli altri preprocessore, assembler, compilatore, linker...) necessari alla generazione di codice eseguibile a partire da sorgenti."

\end_inset


\emph default
 adatta.
\end_layout

\begin_layout Standard
Terminata la parte di configurazione del kernel, come già fatto nella sezione
 
\begin_inset LatexCommand vref
reference "sec:Configurazione-e-compilazione"

\end_inset

, non resta che compilare e testare :)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,extendedchars=true,language=bash,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

$ export CROSS_COMPILE=/usr/local/arm/3.4.1/bin/arm-linux-
\end_layout

\begin_layout Standard

$ make
\end_layout

\end_inset


\end_layout

\begin_layout Standard
È da notare come 
\noun on
CROSS_COMPILE
\noun default
 indichi il prefisso comune a tutti gli eseguibili necessari (
\noun on
arm-linux-gcc
\noun default
, 
\noun on
arm-linux-ld
\noun default
...).
\end_layout

\begin_layout Chapter
Qemu
\end_layout

\begin_layout Standard
Qemu è un emulatore e virtualizzatore generico e open source.
 Nello specifico è stato usato per emulare un'architettura basata su cpu
 
\noun on
ARM
\noun default
 (Versatile
\noun on
 AB
\noun default
 prima, Samsung
\noun on
 S3C2442B
\noun default
 dopo) per semplificare le procedure di testing e debugging del kernel
\end_layout

\begin_layout Section
Come ottenerlo
\end_layout

\begin_layout Standard
Qemu è libero, e già installato nella maggior parte delle distribuzioni.
 Le versioni da noi usate sono state la 0.9.0 e la 0.9.1.
\end_layout

\begin_layout Standard
Se non è già installato sarà sufficiente usare il package manager della
 distribuzione (YaST per OpenSuSE, apt-get per Debian e derivate, installpkg
 per Slackware, eccetera); nella (improbabile) ipotesi che non sia disponibile,
 i sorgenti sono disponibili presso 
\begin_inset LatexCommand htmlurl
target "http://bellard.org/qemu/qemu-0.9.1.tar.gz"

\end_inset

.
\end_layout

\begin_layout Standard
In ogni caso si avrà accesso all'applicazione tramite terminale.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily},breaklines=true,captionpos=tb,extendedchars=true,frame=shadowbox,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Output di
\noun on
 qemu
\noun default
 lanciato senza parametri
\end_layout

\end_inset

$ qemu
\end_layout

\begin_layout Standard

QEMU PC emulator version 0.9.1, Copyright (c) 2003-2008 Fabrice Bellard
\end_layout

\begin_layout Standard

usage: qemu [options] [disk_image]
\end_layout

\begin_layout Standard

'disk_image' is a raw hard image image for IDE hard disk 0
\end_layout

\begin_layout Standard

Standard options:
\end_layout

\begin_layout Standard

-M machine      select emulated machine (-M ? for list)
\end_layout

\begin_layout Standard

-cpu cpu        select CPU (-cpu ? for list)
\end_layout

\begin_layout Standard

-fda/-fdb file  use 'file' as floppy disk 0/1 image
\end_layout

\begin_layout Standard

-hda/-hdb file  use 'file' as IDE hard disk 0/1 image
\end_layout

\begin_layout Standard

-hdc/-hdd file  use 'file' as IDE hard disk 2/3 image
\end_layout

\begin_layout Standard

-cdrom file     use 'file' as IDE cdrom image (cdrom is ide1 master)
\end_layout

\begin_layout Standard

-drive [file=file][,if=type][,bus=n][,unit=m][,media=d][index=i]
\end_layout

\begin_layout Standard

       [,cyls=c,heads=h,secs=s[,trans=t]][snapshot=on|off]       [,cache=on|off]
\end_layout

\begin_layout Standard

                use 'file' as a drive image
\end_layout

\begin_layout Standard

-mtdblock file  use 'file' as on-board Flash memory image
\end_layout

\begin_layout Standard

-sd file        use 'file' as SecureDigital card image
\end_layout

\begin_layout Standard

-pflash file    use 'file' as a parallel flash image
\end_layout

\begin_layout Standard

-boot [a|c|d|n] boot on floppy (a), hard disk (c), CD-ROM (d), or network
 (n)
\end_layout

\begin_layout Standard

-snapshot       write to temporary files instead of disk image files
\end_layout

\begin_layout Standard

-no-frame       open SDL window without a frame and window decorations
\end_layout

\begin_layout Standard

-alt-grab       use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt)
\end_layout

\begin_layout Standard

-no-quit        disable SDL window close capability
\end_layout

\begin_layout Standard

-no-fd-bootchk  disable boot signature checking for floppy disks
\end_layout

\begin_layout Standard

-m megs         set virtual RAM size to megs MB [default=128]
\end_layout

\begin_layout Standard

-smp n          set the number of CPUs to 'n' [default=1]
\end_layout

\begin_layout Standard

-nographic      disable graphical output and redirect serial I/Os to console
\end_layout

\begin_layout Standard

-portrait       rotate graphical output 90 deg left (only PXA LCD)
\end_layout

\begin_layout Standard

-k language     use keyboard layout (for example "fr" for French)
\end_layout

\begin_layout Standard

-audio-help     print list of audio drivers and their options
\end_layout

\begin_layout Standard

-soundhw c1,...
 enable audio support
\end_layout

\begin_layout Standard

                and only specified sound cards (comma separated list)
\end_layout

\begin_layout Standard

                use -soundhw ? to get the list of supported cards
\end_layout

\begin_layout Standard

                use -soundhw all to enable all of them
\end_layout

\begin_layout Standard

-localtime      set the real time clock to local time [default=utc]
\end_layout

\begin_layout Standard

-full-screen    start in full screen
\end_layout

\begin_layout Standard

-win2k-hack     use it when installing Windows 2000 to avoid a disk full
 bug
\end_layout

\begin_layout Standard

-usb            enable the USB driver (will be the default soon)
\end_layout

\begin_layout Standard

-usbdevice name add the host or guest USB device 'name'
\end_layout

\begin_layout Standard

-name string    set the name of the guest
\end_layout

\begin_layout Standard

Network options:
\end_layout

\begin_layout Standard

-net nic[,vlan=n][,macaddr=addr][,model=type]
\end_layout

\begin_layout Standard

                create a new Network Interface Card and connect it to VLAN
 'n'
\end_layout

\begin_layout Standard

-net user[,vlan=n][,hostname=host]
\end_layout

\begin_layout Standard

                connect the user mode network stack to VLAN 'n' and send
\end_layout

\begin_layout Standard

                hostname 'host' to DHCP clients
\end_layout

\begin_layout Standard

-net tap[,vlan=n][,fd=h][,ifname=name][,script=file][,downscript=dfile]
\end_layout

\begin_layout Standard

                connect the host TAP network interface to VLAN 'n' and use
 the
\end_layout

\begin_layout Standard

                network scripts 'file' (default=/etc/qemu-ifup)
\end_layout

\begin_layout Standard

                and 'dfile' (default=/etc/qemu-ifdown);
\end_layout

\begin_layout Standard

                use '[down]script=no' to disable script execution;
\end_layout

\begin_layout Standard

                use 'fd=h' to connect to an already opened TAP interface
\end_layout

\begin_layout Standard

-net socket[,vlan=n][,fd=h][,listen=[host]:port][,connect=host:port]
\end_layout

\begin_layout Standard

                connect the vlan 'n' to another VLAN using a socket connection
\end_layout

\begin_layout Standard

-net socket[,vlan=n][,fd=h][,mcast=maddr:port]
\end_layout

\begin_layout Standard

                connect the vlan 'n' to multicast maddr and port
\end_layout

\begin_layout Standard

-net none       use it alone to have zero network devices; if no -net option
\end_layout

\begin_layout Standard

                is provided, the default is '-net nic -net user'
\end_layout

\begin_layout Standard

-tftp dir       allow tftp access to files in dir [-net user]
\end_layout

\begin_layout Standard

-bootp file     advertise file in BOOTP replies
\end_layout

\begin_layout Standard

-smb dir        allow SMB access to files in 'dir' [-net user]
\end_layout

\begin_layout Standard

-redir [tcp|udp]:host-port:[guest-host]:guest-port
\end_layout

\begin_layout Standard

                redirect TCP or UDP connections from host to guest [-net
 user]
\end_layout

\begin_layout Standard

Linux boot specific:
\end_layout

\begin_layout Standard

-kernel bzImage use 'bzImage' as kernel image
\end_layout

\begin_layout Standard

-append cmdline use 'cmdline' as kernel command line
\end_layout

\begin_layout Standard

-initrd file    use 'file' as initial ram disk
\end_layout

\begin_layout Standard

Debug/Expert options:
\end_layout

\begin_layout Standard

-monitor dev    redirect the monitor to char device 'dev'
\end_layout

\begin_layout Standard

-serial dev     redirect the serial port to char device 'dev'
\end_layout

\begin_layout Standard

-parallel dev   redirect the parallel port to char device 'dev'
\end_layout

\begin_layout Standard

-pidfile file   Write PID to 'file'
\end_layout

\begin_layout Standard

-S              freeze CPU at startup (use 'c' to start execution)
\end_layout

\begin_layout Standard

-s              wait gdb connection to port
\end_layout

\begin_layout Standard

-p port         set gdb connection port [default=1234]
\end_layout

\begin_layout Standard

-d item1,...
    output log to /tmp/qemu.log (use -d ? for a list of log items)
\end_layout

\begin_layout Standard

-hdachs c,h,s[,t]  force hard disk 0 physical geometry and the optional
 BIOS
\end_layout

\begin_layout Standard

                translation (t=none or lba) (usually qemu can guess them)
\end_layout

\begin_layout Standard

-L path         set the directory for the BIOS, VGA BIOS and keymaps
\end_layout

\begin_layout Standard

-kernel-kqemu   enable KQEMU full virtualization (default is user mode only)
\end_layout

\begin_layout Standard

-no-kqemu       disable KQEMU kernel module usage
\end_layout

\begin_layout Standard

-std-vga        simulate a standard VGA card with VESA Bochs Extensions
\end_layout

\begin_layout Standard

                (default is CL-GD5446 PCI VGA)
\end_layout

\begin_layout Standard

-no-acpi        disable ACPI
\end_layout

\begin_layout Standard

-no-reboot      exit instead of rebooting
\end_layout

\begin_layout Standard

-loadvm file    start right away with a saved state (loadvm in monitor)
\end_layout

\begin_layout Standard

-vnc display    start a VNC server on display
\end_layout

\begin_layout Standard

-daemonize      daemonize QEMU after initializing
\end_layout

\begin_layout Standard

-option-rom rom load a file, rom, into the option ROM space
\end_layout

\begin_layout Standard

-clock          force the use of the given methods for timer alarm.
\end_layout

\begin_layout Standard

                To see what timers are available use -clock help
\end_layout

\begin_layout Standard

During emulation, the following keys are useful:
\end_layout

\begin_layout Standard

ctrl-alt-f      toggle full screen
\end_layout

\begin_layout Standard

ctrl-alt-n      switch to virtual console 'n'
\end_layout

\begin_layout Standard

ctrl-alt        toggle mouse and keyboard grab
\end_layout

\begin_layout Standard

When using -nographic, press 'ctrl-a h' to get some help.
\end_layout

\begin_layout Standard

$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per poter emulare anche il chip Samsung
\noun on
 S3C2442B
\noun default
 è stata utilizzata anche una versione di qemu
\emph on
 custom
\emph default
 modificata e manutenuta dagli sviluppatori del progetto openmoko
\begin_inset LatexCommand citep
key "openmoko_under_qemu"

\end_inset

.
\end_layout

\begin_layout Section
Sistemi emulati
\end_layout

\begin_layout LyX-Code
qemu-system-arm -M versatileab ...
\end_layout

\begin_layout Standard
perché qemu non sa ancora emulare l'architettura Samsung S3C2442b (evabé)
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Debugger"

\end_inset

Debugger
\end_layout

\begin_layout Standard
Abbiamo avuto problemi a far partire il kernel di linux sul dispositivo
 palmare, quindi abbiamo cercato di trovare un modo per avere feedback sull'esec
uzione del codice e sugli eventuali errori riscontrati sulla piattaforma.
\end_layout

\begin_layout Standard
Poiché vorremmo analizzare il comportamento di un kernel, però, non è possibile
 utilizzare né 
\noun on
stdout
\noun default
 / 
\noun on
stderr
\noun default
 come canali di comunicazione, né è possibile loggare il comportamento su
 file, in quanto non è ancora disponibile un'interfaccia verso queste strutture
 ad alto livello.
\end_layout

\begin_layout Standard
Per questo motivo abbiamo considerato l'idea di usare un debugger.
 Per poterla applicare, però, avremmo avuto bisogno di un eseguibile per
 il sistema operativo Windows Mobile® che si integrasse con Haret (vedi
 capitolo
\begin_inset LatexCommand vref
reference "cha:Haret"

\end_inset

).
 L'alternativa scelta è stata quella di usare un emulatore per l'architettura,
 e di usare il classico 
\noun on
gdb
\noun default
 per il debug.
\end_layout

\begin_layout Standard
Questa scelta ha semplificato l'analisi e il debug dell'esecuzione delle
 singole istruzioni del codice.
\end_layout

\begin_layout Section
A che serve
\end_layout

\begin_layout Standard
Usare un debugger col kernel è stato utile soprattutto per scoprire 
\begin_inset Quotes eld
\end_inset

qual è la prima funzione invocata
\begin_inset Quotes erd
\end_inset

 dal kernel stesso.
\end_layout

\begin_layout Standard
Se è vero che su architettura x86 vi è la funzione
\family typewriter
 main()
\family default
 in
\family typewriter
 
\family default
\noun on
arch/x86/boot/main.c
\noun default
 che identifica la prima funzione invocata, su architettura 
\noun on
ARM
\noun default
 questo non succede.
\end_layout

\begin_layout Standard
Al contrario, vi sono una serie di cartelle per raggruppare l'implementazione
 delle funzioni per piattaforma e per singolo modello, in quanto il modello
 di distribuzione delle specifiche di 
\noun on
ARM
\noun default
 è diverso dal modello di sviluppo intel
\begin_inset LatexCommand citep
key "arm_intel_mobile"

\end_inset


\end_layout

\begin_layout Section
Quale usare
\end_layout

\begin_layout Standard
Poiché vogliamo usare gdb su un 
\noun on
host
\noun default
 x86, ma con 
\noun on
target
\noun default
 
\noun on
ARM
\noun default
, abbiamo bisogno di usare un debugger
\emph on
 compilato per x86
\emph default
, che sappia tracciare le istruzioni ed estrarre i simboli da un binario
 (il kernel)
\emph on
 compilato per 
\noun on
ARM
\emph default
\noun default
.
\end_layout

\begin_layout Standard
Per questo abbiamo scaricato i sorgenti, li abbiamo estratti e compilati,
 facendo attenzione a impostare 
\noun on
--target=arm-linux
\noun default
 nella fase di configurazione per analizzare binari per ARM.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,extendedchars=true,language=bash,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

$ wget http://ftp.gnu.org/gnu/gdb/gdb-6.8.tar.gz
\end_layout

\begin_layout Standard

$ tar xzf gdb-6.8.tar.gz
\end_layout

\begin_layout Standard

$ cd gdb-6.8
\end_layout

\begin_layout Standard

$ ./configure --target=arm-linux
\end_layout

\begin_layout Standard

$ make && su -c 'make install'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alla fine della fase di compilazione, in 
\noun on
/usr/local/bin
\noun default
 (o dovunque sia stato definito il 
\noun on
PREFIX
\noun default
 in fase di configurazione), saranno stati generati i file 
\noun on
arm-linux-gdb
\noun default
 (il debugger vero e proprio), 
\noun on
arm-linux-gdbtui
\noun default
 (frontend semi-grafico) e 
\noun on
arm-linux-run
\noun default
 (simulatore in grado di eseguire i programmi per 
\noun on
ARM
\noun default
 su x86).
\end_layout

\begin_layout Section
Come usarlo
\end_layout

\begin_layout Standard
Usare un debugger per monitorare processi utente è ragionevolmente facile.
 Le cose si complicano parecchio in caso si voglia debuggare il kernel stesso!
 Questo perché l'attività di debugging altro non è che eseguire un processo
 (il debugger) che, tramite chiamate di sistema (ad esempio tipo la funzione
 
\noun on
ptrace
\noun default
()) analizza il comportamento di un altro processo (il programma da controllare).
\end_layout

\begin_layout Standard
Tuttavia nel caso si voglia controllare il kernel, non è possibile avere
 accesso alle chiamate di sistema stesse (visto che riguardano il programma
 da controllare).
\end_layout

\begin_layout Standard
Tuttavia una soluzione esiste.
\end_layout

\begin_layout Standard
\begin_inset Note Shaded
status open

\begin_layout Standard
TROVARE - SCOPIAZZARE immagine debug remoto fatto con qemu!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lavorando con qemu è possibile impostare l'emulatore (che è un programma
 utente, sulla macchina host) per offrire una connessione a gdb (come se
 si volesse fare debugging remoto su un'altra macchina).
\end_layout

\begin_layout Standard
Per fare ciò basta eseguire qemu aggiungendo le opzioni 
\noun on
-S
\noun default
 (per non far partire la cpu dall'inizio) e 
\noun on
-s
\noun default
 (per attendere una connessione dal 
\begin_inset Quotes eld
\end_inset

client
\begin_inset Quotes erd
\end_inset

 gdb).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,extendedchars=true,language=bash,showstringspaces=false"
inline false
status open

\begin_layout Standard

$ qemu-system-arm -M versatileab -cpu arm926 -sd IMMAGINE_SD -nographic
 -S -s
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo modo il programma rimarrà in attesa.
 Da un altro terminale, quindi, sarà possibile lanciare il debugger.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,extendedchars=true,language=bash,showstringspaces=false"
inline false
status open

\begin_layout Standard

$ arm-linux-gdbtui vmlinux
\end_layout

\end_inset


\end_layout

\begin_layout Standard
quindi scrivo il comando
\end_layout

\begin_layout LyX-Code
target remote :1234
\end_layout

\begin_layout Standard
da lì in poi il debug è quello classico :)
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Haret"

\end_inset

Haret
\end_layout

\begin_layout Standard
Haret
\begin_inset LatexCommand citep*
key "haret_home_page"

\end_inset

 è un boot-loader scritto in C/C++ per Windows Mobile®
\begin_inset LatexCommand nomenclature
symbol "Windows Mobile®"
description "Microsoft® Windows Mobile®, sistema operativo concepito per palmari, telefoni cellulari e Pocket PC"

\end_inset


\end_layout

\begin_layout Section
Perché
\end_layout

\begin_layout Standard
Esistono due modi per far partire linux su un comune palmare.
\end_layout

\begin_layout Itemize
Invasivo
\end_layout

\begin_layout Itemize
Non invasivo
\end_layout

\begin_layout Standard
Nel modo invasivo viene modificato la memoria interna del palmare installandoci
 sopra un bootloader universale Uboot il quale permette di far partire kernel
 anche da remoto sin dall'avvio.
 Con questa modalità però si perde tutto il software preinstallato sulla
 macchina dal momento che si sovrascrive la memoria stessa.
\end_layout

\begin_layout Standard
Nel modo non invasivo viene avviato un programma sotto Windows CE (haret)
 per lanciare il kernel dopo aver disabilitato l'hardware in modo da non
 danneggiarlo.
 Questa è, in effetti, una modalità abbastanza utilizzata anche se vi sono
 problemi di compatibilità tra l'hardware e Haret.
 Sul wiki di Haret è possibili trovare la lista dei dispositivi testati
 ed in fase di testing.
\end_layout

\begin_layout Section
Come
\end_layout

\begin_layout Standard
Il suo obbiettivo è di preparare il dispositivo al lancio del kernel linux.
\end_layout

\begin_layout Standard
Il programma viene copiato all'interno di una scheda di memoria (miniSD)
 con alcuni file di configurazione e il kernel stesso.
 Il file di configurazione 
\emph on
startup.txt
\emph default
:
\end_layout

\begin_layout LyX-Code
\begin_inset Include \verbatiminput{startup.txt}
preview false

\end_inset


\end_layout

\begin_layout Standard
indica all'eseguibile 
\emph on
haret.exe
\emph default
 come settare alcuni parametri (variabili globali all'interno del codice
 di haret) quali KERNEL, MTYPE, INITRD, CMDLINE ed infine avvia la funzione
 (interna al codice di haret quindi scritta in C)
\emph on
 bootlinux.
\end_layout

\begin_layout Section
Codice
\end_layout

\begin_layout Standard
Il codice del programma prevede parti scritte in C/C++ e parti scritte in
 Assembly.
 Le funzioni più interessanti sono presenti all'interno del file 
\noun on
linboot.cpp
\noun default
.
\end_layout

\begin_layout Standard
La funzione
\emph on
 launchKernel
\emph default
 ad esempio è responsabile di inibire l'hardware e lanciare il kernel
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,language=C,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

static void
\end_layout

\begin_layout Standard

launchKernel(struct bootmem *bm)
\end_layout

\begin_layout Standard

{
\end_layout

\begin_layout Standard

// Prep the trampoline.
\end_layout

\begin_layout Standard

uint32 physAddrTram = setupTrampoline();
\end_layout

\begin_layout Standard

if (! physAddrTram)
\end_layout

\begin_layout Standard

return;
\end_layout

\begin_layout Standard

// Cache an mmu pointer for the trampoline
\end_layout

\begin_layout Standard

uint8 *virtAddrMmu = memPhysMap(cpuGetMMU());
\end_layout

\begin_layout Standard

Output("MMU setup: mmu=%p/%08x", virtAddrMmu, cpuGetMMU());
\end_layout

\begin_layout Standard

// Call per-arch setup.
\end_layout

\begin_layout Standard

int ret = Mach->preHardwareShutdown();
\end_layout

\begin_layout Standard

if (ret) {
\end_layout

\begin_layout Standard

Output(C_ERROR "Setup for machine shutdown failed");
\end_layout

\begin_layout Standard

return;
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

Screen("Go Go Go...");
\end_layout

\begin_layout Standard

// Disable interrupts
\end_layout

\begin_layout Standard

take_control();
\end_layout

\begin_layout Standard

fb_clear(&bm->pd->fbi);
\end_layout

\begin_layout Standard

fb_printf(&bm->pd->fbi, "HaRET boot
\backslash
nShutting down hardware
\backslash
n");
\end_layout

\begin_layout Standard

// Call per-arch boot prep function.
\end_layout

\begin_layout Standard

Mach->hardwareShutdown(&bm->pd->fbi);
\end_layout

\begin_layout Standard

fb_printf(&bm->pd->fbi, "Turning off MMU...
\backslash
n");
\end_layout

\begin_layout Standard

// Disable MMU and launch linux.
\end_layout

\begin_layout Standard

mmu_trampoline(physAddrTram, virtAddrMmu, bm->physExec, Mach->flushCache);
\end_layout

\begin_layout Standard

// The above should not ever return, but we attempt recovery here.
\end_layout

\begin_layout Standard

return_control();
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
mentre la funzione
\emph on
 preloader
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,language=C,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

// Code to launch kernel.
\end_layout

\begin_layout Standard

static void __preload
\end_layout

\begin_layout Standard

preloader(struct preloadData *data)
\end_layout

\begin_layout Standard

{
\end_layout

\begin_layout Standard

    data->fbi.fb = (uint16 *)data->physFB;
\end_layout

\begin_layout Standard

    data->fbi.fonts = (unsigned char *)data->physFonts;
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "In preloader
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    uint32 psr = do_cpuGetPSR();
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "PSR=%%x
\backslash

\backslash
n", psr);
\end_layout

\begin_layout Standard

    if ((psr & 0xc0) != 0xc0)
\end_layout

\begin_layout Standard

        FB_PRINTF(&data->fbi, "ERROR: IRQS not off
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    if (fbOverlaps(data)) {
\end_layout

\begin_layout Standard

        FB_PRINTF(&data->fbi, "Disabling framebuffer feedback
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        data->fbi.fb = 0;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    // Copy tags to beginning of ram.
\end_layout

\begin_layout Standard

    char *destTags = (char *)data->startRam + PHYSOFFSET_TAGS;
\end_layout

\begin_layout Standard

    do_copy(destTags, data->tags, TAGSIZE);
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "Tags relocated
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    // Copy kernel image
\end_layout

\begin_layout Standard

    char *destKernel = (char *)data->startRam + PHYSOFFSET_KERNEL;
\end_layout

\begin_layout Standard

    int kernelCount = PAGE_ALIGN(data->kernelSize) / PAGE_SIZE;
\end_layout

\begin_layout Standard

    do_copyPages((char *)destKernel, data->indexPages, 0, kernelCount);
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "Kernel relocated
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    // Copy initrd (if applicable)
\end_layout

\begin_layout Standard

    char *destInitrd = (char *)data->startRam + PHYSOFFSET_INITRD;
\end_layout

\begin_layout Standard

    int initrdCount = PAGE_ALIGN(data->initrdSize) / PAGE_SIZE;
\end_layout

\begin_layout Standard

    do_copyPages(destInitrd, data->indexPages, kernelCount, initrdCount);
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "Initrd relocated
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    // Do CRC check (if enabled).
\end_layout

\begin_layout Standard

    if (data->doCRC) {
\end_layout

\begin_layout Standard

        FB_PRINTF(&data->fbi, "Checking tags crc...");
\end_layout

\begin_layout Standard

        uint32 crc = crc32_be(0, destTags, TAGSIZE);
\end_layout

\begin_layout Standard

        crc = crc32_be_finish(crc, TAGSIZE);
\end_layout

\begin_layout Standard

        if (crc == data->tagsCRC)
\end_layout

\begin_layout Standard

            FB_PRINTF(&data->fbi, "okay
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        else
\end_layout

\begin_layout Standard

            FB_PRINTF(&data->fbi, "FAIL FAIL FAIL
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        FB_PRINTF(&data->fbi, "Checking kernel crc...");
\end_layout

\begin_layout Standard

        crc = crc32_be(0, destKernel, data->kernelSize);
\end_layout

\begin_layout Standard

        crc = crc32_be_finish(crc, data->kernelSize);
\end_layout

\begin_layout Standard

        if (crc == data->kernelCRC)
\end_layout

\begin_layout Standard

            FB_PRINTF(&data->fbi, "okay
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        else
\end_layout

\begin_layout Standard

            FB_PRINTF(&data->fbi, "FAIL FAIL FAIL
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        if (data->initrdSize) {
\end_layout

\begin_layout Standard

            FB_PRINTF(&data->fbi, "Checking initrd crc...");
\end_layout

\begin_layout Standard

            crc = crc32_be(0, destInitrd, data->initrdSize);
\end_layout

\begin_layout Standard

            crc = crc32_be_finish(crc, data->initrdSize);
\end_layout

\begin_layout Standard

            if (crc == data->initrdCRC)
\end_layout

\begin_layout Standard

                FB_PRINTF(&data->fbi, "okay
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

            else
\end_layout

\begin_layout Standard

                FB_PRINTF(&data->fbi, "FAIL FAIL FAIL
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "Jumping to Kernel...
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    // Boot
\end_layout

\begin_layout Standard

    typedef void (*lin_t)(uint32 zero, uint32 mach, char *tags);
\end_layout

\begin_layout Standard

    lin_t startfunc = (lin_t)destKernel;
\end_layout

\begin_layout Standard

    startfunc(0, data->machtype, destTags);
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
è sicuramente la più importante dal momento che nelle ultime tre righe passa
 il controllo al kernel terminando l'esecuzione di haret stesso quindi.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,extendedchars=true,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

typedef void (*lin_t)(uint32 zero, uint32 mach, char *tags);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
viene definita un prototipo di funzione di tipo puntatore a 
\emph on
lin_t
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,extendedchars=true,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

lin_t startfunc = (lin_t)destKernel;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
è definita una variabile startfunc di tipo 
\emph on
lin_t
\emph default
 come cast della variabile 
\emph on
destKernel
\emph default
, buffer di memoria contenente il kernel in ram
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,extendedchars=true,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

startfunc(0, data->machtype, destTags);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
è lanciata la funzione startfunc con in input uno 0, il valore della variabile
 Mtype passata in precedenza e il valore di destTags, buffer di memoria
 contenenti i tags in ram.
\end_layout

\begin_layout Standard
La programmazione in C/C++ è suddivisa in due fasi dal momento che dopo
 lo shutdown dell'hardware il programma accede direttamente alla memoria
 e non riesce a tradurre le funzioni e librerie tipiche del C con conseguente
 uso di funzion ad-hoc.
 Ad esempio nella funzione preloader vi è
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,extendedchars=true,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

FB_PRINTF(&data->fbi, "In preloader
\backslash

\backslash
n");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
la quale risulta una macro definita nel codice in modo seguente
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,extendedchars=true,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

#define STR_IN_CODE(sec,str) ({
\backslash

\end_layout

\begin_layout Standard

    const char *__str;
\backslash

\end_layout

\begin_layout Standard

    asm(".section " #sec ", 1
\backslash
n"
\backslash

\end_layout

\begin_layout Standard

        "1:      .asciz
\backslash
"" str "
\backslash
"
\backslash
n"
\backslash

\end_layout

\begin_layout Standard

        "        .balign 4
\backslash
n"
\backslash

\end_layout

\begin_layout Standard

        "        .section " #sec ", 0
\backslash
n"
\backslash

\end_layout

\begin_layout Standard

        "        add %0, pc, #( 1b - .
 - 8 )
\backslash
n"
\backslash

\end_layout

\begin_layout Standard

        : "=r" (__str));
\backslash

\end_layout

\begin_layout Standard

    __str;
\backslash

\end_layout

\begin_layout Standard

})
\end_layout

\begin_layout Standard

#define FB_PRINTF(fbi,fmt,args...) fb_printf((fbi), STR_IN_CODE(.text.preload,
 fmt) , ##args )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In haret esistono due tipologie di output
\end_layout

\begin_layout Itemize
File di log
\end_layout

\begin_layout Itemize
Stampa a video
\end_layout

\begin_layout Standard
Per abilitare l'output su file di log è necessario creare un file vuoto
 all'interno della cartella dove è presente l'eseguibile 
\emph on
haret.exe
\emph default
 e rinominarlo
\emph on
 earlyharetlog.txt
\emph default
.
 Il file di log 
\emph on
haretlog.txt
\emph default
 verrà creato nella stessa cartella.
 All'interno del codice la funzione
\emph on
 Output
\emph default
 è la responsabile della scrittura su file.
\end_layout

\begin_layout Standard
La seconda tipologia di output si rende necessaria quando avviene lo shutdown
 dell'hardware dal momento che non si ha più accesso alla memoria della
 miniSd.
 All'interno del codice la funzione
\emph on
 fb_printf
\emph default
 stampa a video ove previsto.
\end_layout

\begin_layout Standard
Questo rappresenta la parte finale di un file di log.
 Nella prima parte vi è il riconoscimento della macchina da parte del sistema.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,numbers=left,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

Welcome, this is HaRET pre-0.5.2-20080711_124633 running on WindowsCE v5.1
\end_layout

\begin_layout Standard

Minimal virtual address: 00010000, maximal virtual address: 7FFFFFFF
\end_layout

\begin_layout Standard

Detected machine Panda/s3c2442 (Plat='PocketPC' OEM='PAND100')
\end_layout

\begin_layout Standard

CPU is ARM ARM arch 4T stepping 0 running in system mode
\end_layout

\begin_layout Standard

Enter 'HELP' for a short command summary.
\end_layout

\begin_layout Standard

Running WSAStartup
\end_layout

\begin_layout Standard

Starting gui
\end_layout

\begin_layout Standard

In initdialog
\end_layout

\begin_layout Standard

Found machine Panda
\end_layout

\begin_layout Standard

executing startup.txt
\end_layout

\begin_layout Standard

HaRET(1)# set MTYPE 1806
\end_layout

\begin_layout Standard

HaRET(2)# set KERNEL "zImage"
\end_layout

\begin_layout Standard

HaRET(3)# set CMDLINE "root=/dev/mmcblk0p2 console=tty0 mem=128M rootdelay=5"
\end_layout

\begin_layout Standard

HaRET(4)# bootlinux
\end_layout

\begin_layout Standard

boot KERNEL=zImage INITRD=
\end_layout

\begin_layout Standard

Opening file zImage
\end_layout

\begin_layout Standard

boot params: RAMADDR=30000000 RAMSIZE=08000000 MTYPE=1806 CMDLINE='root=/dev/mmc
blk0p2 console=tty0 mem=128M rootdelay=5'
\end_layout

\begin_layout Standard

Boot FB feedback: 1
\end_layout

\begin_layout Standard

Built virtual to physical page mapping
\end_layout

\begin_layout Standard

Allocated 265 pages (tags=4FB00000/36b4e000 kernel=4FB01000/36b4f000 initrd=4FC0
5000/36a47000 index=4FC05000/36a47000)
\end_layout

\begin_layout Standard

Built kernel tags area
\end_layout

\begin_layout Standard

Built page index
\end_layout

\begin_layout Standard

Video buffer at 52800000 sx=240 sy=320 mx=60 my=53
\end_layout

\begin_layout Standard

Video Phys FB=10800000 Fonts=36a45064
\end_layout

\begin_layout Standard

preload=2260@4FC08000/36a44000 sj=4FC08000 stack=4FC06000/36a46000 data=4FC07000
/36a45000 exec=36a44128
\end_layout

\begin_layout Standard

Reading 1062116 bytes...
\end_layout

\begin_layout Standard

Read complete
\end_layout

\begin_layout Standard

Launching to physical address 36a44010
\end_layout

\begin_layout Standard

Trampoline setup (tram=136@00024AEC/1c024aec/30882aec)
\end_layout

\begin_layout Standard

MMU setup: mmu=A0250000/30550000
\end_layout

\begin_layout Standard

Go Go Go...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si noti come al terzo rigo avvisa dell'avvenuto riconoscimento della macchina
 e della tipologia di cpu.
 Poi parte nell'esecuzione del contenuto di
\emph on
 startup.txt
\emph default
 come fossero comandi separati tra loro (si noti il carattere # indicatore
 della pseudo-shell).
 L'ultimo comando è appunto
\emph on
 bootlinux
\emph default
 il quale fa partire l'esecuzione del codice visto in precedenza.
 Alla fine del file di log vi è la scritta
\emph on
 Go Go Go ...

\emph default
 che è l'ultimo messaggio previsto dal codice prima di spegnere l'hardware
 e lasciare l'esecuzione al kernel.
 La presenza di questo messaggio quindi implica il successo nell'esecuzione
 di haret.
 Tutti gli eventuali problemi successivi saranno dovuti al kernel non più
 ad haret.
\end_layout

\begin_layout Section
Problemi
\end_layout

\begin_layout Standard
Abbiamo constatato delle difficoltà a debuggare su un sistema embedded.
\end_layout

\begin_layout Standard
Nel nostro caso avevamo problemi dal momento che ci appariva la scritta
 
\emph on
Go Go Go...

\emph default
 ma il kernel non partiva.
\end_layout

\begin_layout Standard
Eravamo quindi davanti una serie di possibili cause da dimostrare.
\end_layout

\begin_layout Standard
Il primo dubbio risolto riguardava errori presenti all'interno del codice
 di haret.
 Con un'attento debug tramite stringhe stampate sullo schermo ci siamo accertati
 che effettivamente il controllo passava al kernel (tre righe finali viste
 in precedenza).
\end_layout

\begin_layout Standard
Il dubbio immediatamente successivo riguardava un problema di errato passaggio
 del file del kernel.
\end_layout

\begin_layout Standard
Anche in questo caso abbiamo stampato a video e confrontato bit a bit il
 file del kernel con il contenuto del buffer di memoria che veniva avviato
 da haret.
\end_layout

\begin_layout Chapter
U-Boot
\end_layout

\begin_layout Standard
To do.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "bibtotoc,alpha"
bibfiles "web-o-grafia"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand printnomenclature

\end_inset


\end_layout

\end_body
\end_document
