#LyX 1.5.5 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{hyperref}
\end_preamble
\language italian
\inputencoding auto
\font_roman bookman
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize 12
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "basicstyle={\normalsize\ttfamily},captionpos=tb,extendedchars=true,frame=shadowbox,showstringspaces=false"
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
GNU/Linux su ARM
\end_layout

\begin_layout Author
Vito De Tullio 
\hfill

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
href{mailto:vito.detullio@gmail.com}{vito.detullio@gmail.com}
\end_layout

\end_inset


\newline
Nicola Corriero 
\hfill

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
href{mailto:ncorriero@di.uniba.it}{ncorriero@di.uniba.it}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Kernel
\end_layout

\begin_layout Standard
È stato usata la versione 2.6.25.10 del kernel vanilla (versione di default,
 non patchata) reperibile presso 
\begin_inset LatexCommand htmlurl
target "ftp://ftp.kernel.org/pub/linux/kernel/v2.6/linux-2.6.25.10.tar.bz2"

\end_inset

.
 Esistono versioni modificate da singoli per supportare questa o quell'architett
ura (in particolare è da notare la versione del kernel mantenuta da 
\begin_inset LatexCommand htmlurl
target "http://www.handhelds.org"

\end_inset

), ma non abbiamo trovato nessuna versione che già supportasse nativamente
 il nostro palmare (un 
\noun on
HTC P6300
\noun default
) e quindi abbiamo preferito utilizzare la versione di default.
\end_layout

\begin_layout Section
Configurazione e compilazione
\end_layout

\begin_layout Standard
Dopo aver estratto il kernel, lo dobbiamo configurare per l'architettura
 
\noun on
ARM
\noun default
 utilizzando un x86, e per questo, prima del solito
\family typewriter
 make [x|menu]config
\family default
, è necessario associare alla variabile
\family typewriter
 ARCH
\family default
 il valore
\family typewriter
 arm
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,extendedchars=true,language=bash,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard
$ wget ftp://ftp.kernel.org/pub/linux/kernel/v2.6/linux-2.6.25.10.tar.bz2
\end_layout

\begin_layout Standard
$ tar xjf kernel-2.6.25.10.tar.bz2
\end_layout

\begin_layout Standard
$ cd kernel-2.6.25.10
\end_layout

\begin_layout Standard
$ export ARCH=arm
\end_layout

\begin_layout Standard
$ make menuconfig
\end_layout

\end_inset


\end_layout

\begin_layout Standard
È necessario prestare attenzione soprattutto al modello di palmare su cui
 vogliamo eseguire il kernel, più altre minuzie per far funzionare i vari
 dispositivi; in particolare
\end_layout

\begin_layout Itemize
Dal menù
\noun on
 System Type \SpecialChar \menuseparator
 Arm System Type
\noun default
 scegliamo il tipo di sistema base (nel nostro caso
\noun on
 Samsung S3C2410, S3C2412, S3C2413, S3C2440, S3C2442, S3C2443
\noun default
).
\end_layout

\begin_layout Itemize
Dal menù
\noun on
 Boot options
\noun default
 impostiamo
\series bold
\noun on
 console=ttyAMA0
\series default
\noun default
 alla voce
\noun on
 Default kernel command string
\noun default
 (per poter avere in output i messaggi di comunicazione); per avere informazioni
 il prima possibile, inoltre, conviene impostare, dal menù
\noun on
 General setup
\series bold
 12
\series default
\noun default
 come valore della voce
\noun on
 Kernel log buffer size
\noun default
.
\end_layout

\begin_layout Itemize
Dal menù
\noun on
 Device Drivers
\noun default
 selezioniamo
\noun on
 MMC/SD card support
\noun default
 (per poter accedere al supporto fisico per il file system).
\end_layout

\begin_layout Standard
Dopo anche altre personalizzazioni minori, si giunge al .config finale, che,
 nel nostro caso, è abbastanza minimale: la maggior parte dei moduli, infatti,
 è stata disabilitata, tranne quelli necessari a riconoscere cpu, tastiera
 e monitor:
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{_CONFIGURE_VANIGLIA_VERSATILE_2.6.25.10_no_comments}[basicstyle={\tiny\ttfamily},caption={.config finale utilizzato (le voci commentate sono state rimosse)}]
preview false

\end_inset


\end_layout

\begin_layout Standard
Alla fine della fase di configurazione, basterà lanciare
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=bash,showstringspaces=false"
inline false
status open

\begin_layout Standard
$ make
\end_layout

\end_inset


\end_layout

\begin_layout Standard
per dare il via alla fase di compilazione vera e propria dei sorgenti.
\end_layout

\begin_layout Section
Output (Image, zImage + compressore)
\end_layout

\begin_layout Standard
Terminata la fase di compilazione, verranno generati, oltre ad una serie
 di file temporanei / di supporto, i seguenti file.
\end_layout

\begin_layout Description

\family typewriter
vmlinux
\begin_inset LatexCommand nomenclature
symbol "vmlinux"
description "Eseguibile non compresso e non bootable del kernel."

\end_inset


\family default
 eseguibile
\emph on
 non compresso
\emph default
 e
\emph on
 non bootable
\emph default
 del kernel.
 Usato soprattutto per debug, come vedremo nel capitolo
\begin_inset LatexCommand vref
reference "cha:Debugger"

\end_inset

.
\end_layout

\begin_layout Description

\family typewriter
Image
\begin_inset LatexCommand nomenclature
symbol "Image"
description "Immagine del kernel effettivamente eseguita"

\end_inset


\family default
 immagine del kernel effettivamente eseguita
\end_layout

\begin_layout Description

\family typewriter
zImage
\begin_inset LatexCommand nomenclature
symbol "zImage"
description "Immagine del kernel compressa preceduta da un decompressore (obsoleta)"

\end_inset


\family default
 immagine del kernel, compressa tramite gzip e preceduta da un decompressore
 (obsoleta)
\end_layout

\begin_layout Description

\family typewriter
\begin_inset LatexCommand nomenclature
symbol "bzImage"
description "Immagine del kernel compressa ed eseguibile, ma composta da tre parti separate"

\end_inset

bzImage\InsetSpace ~

\family default
(
\begin_inset LatexCommand nomenclature
symbol "big zImage"
description "vedi bzImage"

\end_inset

big\InsetSpace ~

\family typewriter
zImage
\family default
) concatenatzione di
\family typewriter
 bootsect.o
\family default
 +
\family typewriter
 setup.o
\family default
 +
\family typewriter
 misc.o
\family default
 +
\family typewriter
 piggy.o
\family default
.
\begin_inset LatexCommand citep
key "vmlinuz_definition,vmlinux_zimage"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Anatomy-of-bzimage.png
	lyxscale 50
	width 80col%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Anatomia di bzImage (da 
\begin_inset LatexCommand htmlurl
target "en.wikipedia.org"

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Section
Avvio
\end_layout

\begin_layout Standard
Una volta che il bootloader ha caricato il kernel in memoria e l'ha eseguito,
 vi è la fase di bootstrap
\begin_inset LatexCommand nomenclature
symbol "bootstrap"
description "Letteralmente la fascetta di cuoio cucita sul bordo posteriore degli stivali per aiutarsi a calzarli, fa riferimento alla leggenda del Barone di Münchhausen e alla sua capacità di sollevarsi in aria \"tirandosi per gli stivali\".\\\\Indica la fase di avvio di un pc"

\end_inset

 che, nell'architettura 
\noun on
ARM
\noun default
, è implementata per la maggior parte in assembly.
\end_layout

\begin_layout Subsection
Sorgenti
\end_layout

\begin_layout Standard
Il codice che si prende carico del boot del sistema è presente nelle directory
 
\noun on
arch/arm/boot/compressed
\noun default
 e 
\noun on
arch/arm/kernel
\noun default
 ove sono presenti, oltre a del codice d'appoggio per comprimere e decomprimere
 l'eseguibile, anche una serie di file 
\noun on
.S
\noun default
 (scritti in assembly per 
\noun on
ARM
\noun default
) tra i quali sono degni di nota i 2 file 
\noun on
head.S
\noun default
.
\end_layout

\begin_layout Standard

\noun on
arch/arm/kernel/head.S
\noun default
, in particolare, contiene la parte di codice che, di fatto, è il punto
 di partenza del kernel.
 In effetti questo codice, compilato, corrisponde alle prime istruzioni
 presenti in nel file 
\noun on
Image
\noun default
 già descritto;
\end_layout

\begin_layout Standard
Ovviamente nel caso si decida di usare i file 
\noun on
zImage
\noun default
 e 
\noun on
bzImage
\noun default
, questo codice sarà quello invocato al termine della decompressione del
 kernel stesso.
\end_layout

\begin_layout Standard
Ciò si evince anche dai commenti presenti nel file, come si può vedere:
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,firstnumber=59,language=C,numbers=left,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

/*
\end_layout

\begin_layout Standard

 * Kernel startup entry point.
\end_layout

\begin_layout Standard

 * ---------------------------
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * This is normally called from the decompressor code.
 The requirements
\end_layout

\begin_layout Standard

 * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
\end_layout

\begin_layout Standard

 * r1 = machine nr, r2 = atags pointer.
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * This code is mostly position independent, so if you link the kernel at
\end_layout

\begin_layout Standard

 * 0xc0008000, you call this at __pa(0xc0008000).
\end_layout

\begin_layout Standard

 *
\end_layout

\begin_layout Standard

 * See linux/arch/arm/tools/mach-types for the complete list of machine
\end_layout

\begin_layout Standard

 * numbers for r1.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In particolare, viene fatto riferimento al file 
\noun on
arch/arm/tools/mach-types
\noun default
: questi altro non è che un 
\begin_inset Quotes eld
\end_inset

database
\begin_inset Quotes erd
\end_inset

 in cui si associa ad ogni modello supportato dal kernel che implementa
 le specifiche dell'
\noun on
ARM
\noun default
, una serie di codici univoci usati per poter generare delle guardie per
 implementare codice dipendente da macchina a macchina.
 Questo file è mantenuto dal 
\begin_inset Quotes eld
\end_inset

The ARM Linux Project
\begin_inset Quotes erd
\end_inset


\begin_inset LatexCommand citep
key "mach_types_home_page"

\end_inset

, che assicura l'univocità degli identificatori usati per i vari palmari.
\end_layout

\begin_layout Standard
In aggiunta a questo file vi è uno script awk (
\noun on
arch/arm/tools/gen-mach-types
\noun default
) capace di trasformare questo file di configurazione nel file 
\noun on
include/asm-arm/mach-types.h
\noun default
, pieno di macro usate in fase di compilazione per abilitare o meno il codice
 specifico della macchina target.
\end_layout

\begin_layout Subsection
Boot
\end_layout

\begin_layout Standard
Tornando alla sequenza di boot, analizziamo un attimo le prime istruzioni
 presenti in
\noun on
 arch/arm/kernel/head.S
\noun default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,extendedchars=true,firstnumber=77,language={[x86masm]Assembler},numbers=left,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

        .section ".text.head", "ax"
\end_layout

\begin_layout Standard

        .type   stext, %function
\end_layout

\begin_layout Standard

ENTRY(stext)
\end_layout

\begin_layout Standard

        msr     cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode
\end_layout

\begin_layout Standard

                                                @ and irqs disabled
\end_layout

\begin_layout Standard

        mrc     p15, 0, r9, c0, c0              @ get processor id
\end_layout

\begin_layout Standard

        bl      __lookup_processor_type         @ r5=procinfo r9=cpuid
\end_layout

\begin_layout Standard

        movs    r10, r5                         @ invalid processor (r5=0)?
\end_layout

\begin_layout Standard

        beq     __error_p                       @ yes, error 'p'
\end_layout

\begin_layout Standard

        bl      __lookup_machine_type           @ r5=machinfo
\end_layout

\begin_layout Standard

        movs    r8, r5                          @ invalid machine (r5=0)?
\end_layout

\begin_layout Standard

        beq     __error_a                       @ yes, error 'a'
\end_layout

\begin_layout Standard

        bl      __vet_atags
\end_layout

\begin_layout Standard

        bl      __create_page_tables
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

        /*
\end_layout

\begin_layout Standard

         * The following calls CPU specific code in a position independent
\end_layout

\begin_layout Standard

         * manner.
  See arch/arm/mm/proc-*.S for details.
  r10 = base of
\end_layout

\begin_layout Standard

         * xxx_proc_info structure selected by __lookup_machine_type
\end_layout

\begin_layout Standard

         * above.
  On return, the CPU will be ready for the MMU to be
\end_layout

\begin_layout Standard

         * turned on, and r0 will hold the CPU control register value.
\end_layout

\begin_layout Standard

        */
\end_layout

\begin_layout Standard

        ldr     r13, __switch_data              @ address to jump to after
\end_layout

\begin_layout Standard

                                                @ mmu has been enabled
\end_layout

\begin_layout Standard

        adr     lr, __enable_mmu                @ return (PIC) address
\end_layout

\begin_layout Standard

        add     pc, r10, #PROCINFO_INITFUNC
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
All'inizio degni di nota sono soprattutto i controlli effettuati dal kernel
 sulla possibilità di supportare processore e macchina.
 
\end_layout

\begin_layout Standard
In caso d'errore vengono invocate delle funzioni per avvisare l'utente -
 e terminare l'esecuzione del programma.
 
\end_layout

\begin_layout Standard
Una volta superati i controlli l'esecuzione continua ri-abilitando la 
\noun on
MMU
\noun default

\begin_inset LatexCommand nomenclature
symbol "MMU"
description "Memory Management Unit"

\end_inset

 e eseguendo il codice specifico della cpu.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Subsection
Dal click al bios
\end_layout

\begin_layout Standard
C'è poco da dire: fondamentalmente è tutto hardware, quindi
\emph on
black magic
\emph default
, e, oltretutto, poco interessante.
 In sostanza arriva un segnale al trasformatore dal pulsante, che inizia
 ad alimentare la
\noun on
cpu
\noun default
, che esegue il programma contenuto in una
\noun on
rom
\noun default
,
\noun on
nvram
\noun default
, o
\noun on
cmos ram
\noun default
.
 Viene lanciato il bios, che ha il compito di verificare alcune funzioni
 fondamentali (che arrivi la corrente alla cpu, alla ram e alle varie periferich
e...) e di eseguire il contenuto dell'
\noun on
mbr.
\end_layout

\begin_layout Subsection
Dal bios al bootloader
\end_layout

\begin_layout Standard
Anche qui c'è poco da dire.
\end_layout

\begin_layout Subsection
Dal bootloader a
\family typewriter
init
\end_layout

\begin_layout Standard
I primi istanti di
\end_layout

\begin_layout Standard
Il modo più facile per analizzare il comportamento del kernel è usando un
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Compilatore
\end_layout

\begin_layout Standard
L'altra componente necessaria per compilare un kernel è, ovviamente, un
 compilatore :)
\end_layout

\begin_layout Section
Quale
\end_layout

\begin_layout Standard
Per compilare il kernel linux è necessario usare il gcc, a causa delle varie
 estensioni del compilatore utilizzate dai 
\emph on
kernel hackers
\emph default
.
 
\end_layout

\begin_layout Standard
Sulla versione da utilizzare non ci sono preferenze, ma, in genere, più
 nuovo è, meglio è.
\end_layout

\begin_layout Standard
In effetti ci potrebbero essere problemi in caso di versioni del kernel
 e del compilatore particolarmente differenti tra di loro, a causa dell'uso
 (e spesso dell'abuso) che viene fatto delle varie estensioni 
\emph on
non standard
\emph default
.
 
\end_layout

\begin_layout Standard
Nel nostro caso sono state usate varie versioni, principalmente 4.2.3 e 3.4.1,
 senza riscontrare particolari problemi.
\end_layout

\begin_layout Section
Cross-compilazione
\end_layout

\begin_layout Standard
Per compilare un kernel per 
\noun on
ARM
\noun default
 ci sono le seguenti opzioni:
\end_layout

\begin_layout Enumerate
Avere un sistema operativo + compilatore 
\noun on
C
\noun default
 su architettura 
\noun on
ARM
\noun default
 (e parecchio tempo, data la potenza di questi dispositivi).
\end_layout

\begin_layout Enumerate
\begin_inset LatexCommand label
name "enu:cross-compilare"

\end_inset

Avere un sistema operativo + compilatore 
\noun on
C
\noun default
 su architettura x86 + istruire il compilatore 
\noun on
C
\noun default
 a generare eseguibili per architettura 
\noun on
ARM
\noun default
.
\end_layout

\begin_layout Standard
Si è scelto di approcciarsi al problema tramite la soluzione 
\begin_inset LatexCommand ref
reference "enu:cross-compilare"

\end_inset

.
 D'ora innanzi, quindi, si dirà
\end_layout

\begin_layout Description

\noun on
host
\begin_inset LatexCommand nomenclature
symbol "host"
description "In ambiente di emulazione, la macchina reale che ospita l'emulatore.\\\\In ambiente di cross-compilazione, la macchina che ospita il compilatore.\\\\Vedi: target"

\end_inset


\noun default
 la macchina x86 su cui sono presenti compilatore e sorgenti
\end_layout

\begin_layout Description

\noun on
target
\begin_inset LatexCommand nomenclature
symbol "target"
description "In ambiente di emulazione, la macchina virtuale generata dall'emulatore.\\\\In ambiente di cross-compilazione, la macchina su cui verranno utilizzati i programmi compilati.\\\\Vedi: host"

\end_inset


\noun default
 la macchina ARM su cui si utilizzerà effettivamente il kernel compilato
\end_layout

\begin_layout Standard
Ciò comporta una serie di vantaggi:
\end_layout

\begin_layout Itemize
Si può utilizzare come 
\noun on
host
\noun default
 un sistema linux già funzionante (nel nostro caso, sono stati utilizzati
 una debian Lenny e una OpenSuse 10.3)
\end_layout

\begin_layout Itemize
La capacità di calcolo di una macchina
\noun on
 target
\noun default
 è generalmente limitata, mentre le macchine
\noun on
 host
\noun default
 sono molto più potenti (minimizzando i tempi morti in attesa del termine
 della compilazione)
\end_layout

\begin_layout Itemize
\begin_inset Note Shaded
status open

\begin_layout Standard
TROVARE ALTRI VANTAGGI??
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ovviamente vi è la difficoltà di avere un compilatore 
\noun on
C
\noun default
 in grado di generare eseguibili per la macchina
\noun on
 target
\noun default
.
 Per fortuna questo è offerto da gcc.
 Per abilitare questa
\emph on
 feature
\emph default
, però, è necessario impostare una opzione in fase di compilazione.
\end_layout

\begin_layout Standard
Nel nostro caso si è evitato di ri-compilare il compilatore, ed è stata
 utilizzata una versione pre-compilata di gcc da 
\begin_inset LatexCommand htmlurl
name "handhelds.org"
target "http://www.handhelds.org/download/projects/toolchain/"

\end_inset


\begin_inset LatexCommand citep
key "handhelds_toolchain"

\end_inset

.
\end_layout

\begin_layout Chapter
qemu
\end_layout

\begin_layout Standard
Qemu è un emulatore e virtualizzatore generico e open source.
 Nello specifico è stato usato per emulare un'architettura basata su cpu
 
\noun on
ARM
\noun default
 (Versatile
\noun on
 AB
\noun default
 prima, Samsung
\noun on
 S3C2442B
\noun default
 dopo) per semplificare le procedure di testing e debugging del kernel
\end_layout

\begin_layout Section
Come ottenerlo
\end_layout

\begin_layout Standard
Qemu è libero, e già installato nella maggior parte delle distribuzioni.
 Le versioni da noi usate sono state la 0.9.0 e la 0.9.1.
\end_layout

\begin_layout Standard
Se non è già installato sarà sufficiente usare il package manager della
 distribuzione (YaST per OpenSuSE, apt-get per Debian e derivate, installpkg
 per Slackware, eccetera); nella (improbabile) ipotesi che non sia disponibile,
 i sorgenti sono disponibili presso 
\begin_inset LatexCommand htmlurl
target "http://bellard.org/qemu/qemu-0.9.1.tar.gz"

\end_inset

.
\end_layout

\begin_layout Standard
In ogni caso si avrà accesso all'applicazione tramite terminale.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily},breaklines=true,captionpos=tb,extendedchars=true,frame=shadowbox,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Output di
\noun on
 qemu
\noun default
 lanciato senza parametri
\end_layout

\end_inset

$ qemu
\end_layout

\begin_layout Standard

QEMU PC emulator version 0.9.1, Copyright (c) 2003-2008 Fabrice Bellard
\end_layout

\begin_layout Standard

usage: qemu [options] [disk_image]
\end_layout

\begin_layout Standard

'disk_image' is a raw hard image image for IDE hard disk 0
\end_layout

\begin_layout Standard

Standard options:
\end_layout

\begin_layout Standard

-M machine      select emulated machine (-M ? for list)
\end_layout

\begin_layout Standard

-cpu cpu        select CPU (-cpu ? for list)
\end_layout

\begin_layout Standard

-fda/-fdb file  use 'file' as floppy disk 0/1 image
\end_layout

\begin_layout Standard

-hda/-hdb file  use 'file' as IDE hard disk 0/1 image
\end_layout

\begin_layout Standard

-hdc/-hdd file  use 'file' as IDE hard disk 2/3 image
\end_layout

\begin_layout Standard

-cdrom file     use 'file' as IDE cdrom image (cdrom is ide1 master)
\end_layout

\begin_layout Standard

-drive [file=file][,if=type][,bus=n][,unit=m][,media=d][index=i]
\end_layout

\begin_layout Standard

       [,cyls=c,heads=h,secs=s[,trans=t]][snapshot=on|off]       [,cache=on|off]
\end_layout

\begin_layout Standard

                use 'file' as a drive image
\end_layout

\begin_layout Standard

-mtdblock file  use 'file' as on-board Flash memory image
\end_layout

\begin_layout Standard

-sd file        use 'file' as SecureDigital card image
\end_layout

\begin_layout Standard

-pflash file    use 'file' as a parallel flash image
\end_layout

\begin_layout Standard

-boot [a|c|d|n] boot on floppy (a), hard disk (c), CD-ROM (d), or network
 (n)
\end_layout

\begin_layout Standard

-snapshot       write to temporary files instead of disk image files
\end_layout

\begin_layout Standard

-no-frame       open SDL window without a frame and window decorations
\end_layout

\begin_layout Standard

-alt-grab       use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt)
\end_layout

\begin_layout Standard

-no-quit        disable SDL window close capability
\end_layout

\begin_layout Standard

-no-fd-bootchk  disable boot signature checking for floppy disks
\end_layout

\begin_layout Standard

-m megs         set virtual RAM size to megs MB [default=128]
\end_layout

\begin_layout Standard

-smp n          set the number of CPUs to 'n' [default=1]
\end_layout

\begin_layout Standard

-nographic      disable graphical output and redirect serial I/Os to console
\end_layout

\begin_layout Standard

-portrait       rotate graphical output 90 deg left (only PXA LCD)
\end_layout

\begin_layout Standard

-k language     use keyboard layout (for example "fr" for French)
\end_layout

\begin_layout Standard

-audio-help     print list of audio drivers and their options
\end_layout

\begin_layout Standard

-soundhw c1,...
 enable audio support
\end_layout

\begin_layout Standard

                and only specified sound cards (comma separated list)
\end_layout

\begin_layout Standard

                use -soundhw ? to get the list of supported cards
\end_layout

\begin_layout Standard

                use -soundhw all to enable all of them
\end_layout

\begin_layout Standard

-localtime      set the real time clock to local time [default=utc]
\end_layout

\begin_layout Standard

-full-screen    start in full screen
\end_layout

\begin_layout Standard

-win2k-hack     use it when installing Windows 2000 to avoid a disk full
 bug
\end_layout

\begin_layout Standard

-usb            enable the USB driver (will be the default soon)
\end_layout

\begin_layout Standard

-usbdevice name add the host or guest USB device 'name'
\end_layout

\begin_layout Standard

-name string    set the name of the guest
\end_layout

\begin_layout Standard

Network options:
\end_layout

\begin_layout Standard

-net nic[,vlan=n][,macaddr=addr][,model=type]
\end_layout

\begin_layout Standard

                create a new Network Interface Card and connect it to VLAN
 'n'
\end_layout

\begin_layout Standard

-net user[,vlan=n][,hostname=host]
\end_layout

\begin_layout Standard

                connect the user mode network stack to VLAN 'n' and send
\end_layout

\begin_layout Standard

                hostname 'host' to DHCP clients
\end_layout

\begin_layout Standard

-net tap[,vlan=n][,fd=h][,ifname=name][,script=file][,downscript=dfile]
\end_layout

\begin_layout Standard

                connect the host TAP network interface to VLAN 'n' and use
 the
\end_layout

\begin_layout Standard

                network scripts 'file' (default=/etc/qemu-ifup)
\end_layout

\begin_layout Standard

                and 'dfile' (default=/etc/qemu-ifdown);
\end_layout

\begin_layout Standard

                use '[down]script=no' to disable script execution;
\end_layout

\begin_layout Standard

                use 'fd=h' to connect to an already opened TAP interface
\end_layout

\begin_layout Standard

-net socket[,vlan=n][,fd=h][,listen=[host]:port][,connect=host:port]
\end_layout

\begin_layout Standard

                connect the vlan 'n' to another VLAN using a socket connection
\end_layout

\begin_layout Standard

-net socket[,vlan=n][,fd=h][,mcast=maddr:port]
\end_layout

\begin_layout Standard

                connect the vlan 'n' to multicast maddr and port
\end_layout

\begin_layout Standard

-net none       use it alone to have zero network devices; if no -net option
\end_layout

\begin_layout Standard

                is provided, the default is '-net nic -net user'
\end_layout

\begin_layout Standard

-tftp dir       allow tftp access to files in dir [-net user]
\end_layout

\begin_layout Standard

-bootp file     advertise file in BOOTP replies
\end_layout

\begin_layout Standard

-smb dir        allow SMB access to files in 'dir' [-net user]
\end_layout

\begin_layout Standard

-redir [tcp|udp]:host-port:[guest-host]:guest-port
\end_layout

\begin_layout Standard

                redirect TCP or UDP connections from host to guest [-net
 user]
\end_layout

\begin_layout Standard

Linux boot specific:
\end_layout

\begin_layout Standard

-kernel bzImage use 'bzImage' as kernel image
\end_layout

\begin_layout Standard

-append cmdline use 'cmdline' as kernel command line
\end_layout

\begin_layout Standard

-initrd file    use 'file' as initial ram disk
\end_layout

\begin_layout Standard

Debug/Expert options:
\end_layout

\begin_layout Standard

-monitor dev    redirect the monitor to char device 'dev'
\end_layout

\begin_layout Standard

-serial dev     redirect the serial port to char device 'dev'
\end_layout

\begin_layout Standard

-parallel dev   redirect the parallel port to char device 'dev'
\end_layout

\begin_layout Standard

-pidfile file   Write PID to 'file'
\end_layout

\begin_layout Standard

-S              freeze CPU at startup (use 'c' to start execution)
\end_layout

\begin_layout Standard

-s              wait gdb connection to port
\end_layout

\begin_layout Standard

-p port         set gdb connection port [default=1234]
\end_layout

\begin_layout Standard

-d item1,...
    output log to /tmp/qemu.log (use -d ? for a list of log items)
\end_layout

\begin_layout Standard

-hdachs c,h,s[,t]  force hard disk 0 physical geometry and the optional
 BIOS
\end_layout

\begin_layout Standard

                translation (t=none or lba) (usually qemu can guess them)
\end_layout

\begin_layout Standard

-L path         set the directory for the BIOS, VGA BIOS and keymaps
\end_layout

\begin_layout Standard

-kernel-kqemu   enable KQEMU full virtualization (default is user mode only)
\end_layout

\begin_layout Standard

-no-kqemu       disable KQEMU kernel module usage
\end_layout

\begin_layout Standard

-std-vga        simulate a standard VGA card with VESA Bochs Extensions
\end_layout

\begin_layout Standard

                (default is CL-GD5446 PCI VGA)
\end_layout

\begin_layout Standard

-no-acpi        disable ACPI
\end_layout

\begin_layout Standard

-no-reboot      exit instead of rebooting
\end_layout

\begin_layout Standard

-loadvm file    start right away with a saved state (loadvm in monitor)
\end_layout

\begin_layout Standard

-vnc display    start a VNC server on display
\end_layout

\begin_layout Standard

-daemonize      daemonize QEMU after initializing
\end_layout

\begin_layout Standard

-option-rom rom load a file, rom, into the option ROM space
\end_layout

\begin_layout Standard

-clock          force the use of the given methods for timer alarm.
\end_layout

\begin_layout Standard

                To see what timers are available use -clock help
\end_layout

\begin_layout Standard

During emulation, the following keys are useful:
\end_layout

\begin_layout Standard

ctrl-alt-f      toggle full screen
\end_layout

\begin_layout Standard

ctrl-alt-n      switch to virtual console 'n'
\end_layout

\begin_layout Standard

ctrl-alt        toggle mouse and keyboard grab
\end_layout

\begin_layout Standard

When using -nographic, press 'ctrl-a h' to get some help.
\end_layout

\begin_layout Standard

$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per poter emulare anche il chip Samsung
\noun on
 S3C2442B
\noun default
 è stata utilizzata anche una versione di qemu
\emph on
 custom
\emph default
 modificata e manutenuta dagli sviluppatori del progetto openmoko
\begin_inset LatexCommand citep
key "openmoko_under_qemu"

\end_inset

.
\end_layout

\begin_layout Section
Sistemi emulati
\end_layout

\begin_layout LyX-Code
qemu-system-arm -M versatileab ...
\end_layout

\begin_layout Standard
perché qemu non sa ancora emulare l'architettura Samsung S3C2442b (evabé)
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Debugger"

\end_inset

Debugger
\end_layout

\begin_layout Standard
Abbiamo avuto problemi a far partire il kernel di linux sul dispositivo
 palmare, quindi abbiamo cercato di trovare un modo per avere feedback sull'esec
uzione del codice e sugli eventuali errori riscontrati sulla piattaforma.
\end_layout

\begin_layout Standard
Poiché vorremmo analizzare il comportamento di un kernel, però, non è possibile
 utilizzare né 
\noun on
stdout
\noun default
 / 
\noun on
stderr
\noun default
 come canali di comunicazione, né è possibile loggare il comportamento su
 file, in quanto non è ancora disponibile un'interfaccia verso queste strutture
 ad alto livello.
\end_layout

\begin_layout Standard
Per questo motivo abbiamo considerato l'idea di usare un debugger.
 Per poterla applicare, però, avremmo avuto bisogno di un eseguibile per
 il sistema operativo Windows Mobile® che si integrasse con Haret (vedi
 capitolo
\begin_inset LatexCommand vref
reference "cha:Haret"

\end_inset

).
 L'alternativa scelta è stata quella di usare un emulatore per l'architettura,
 e di usare il classico 
\noun on
gdb
\noun default
 per il debug.
\end_layout

\begin_layout Standard
Questa scelta ha semplificato l'analisi e il debug dell'esecuzione delle
 singole istruzioni del codice.
\end_layout

\begin_layout Section
A che serve
\end_layout

\begin_layout Standard
Usare un debugger col kernel è stato utile soprattutto per scoprire 
\begin_inset Quotes eld
\end_inset

qual è la prima funzione invocata
\begin_inset Quotes erd
\end_inset

 dal kernel stesso.
\end_layout

\begin_layout Standard
Se è vero che su architettura x86 vi è la funzione
\family typewriter
 main()
\family default
 in
\family typewriter
 
\family default
\noun on
arch/x86/boot/main.c
\noun default
 che identifica la prima funzione invocata, su architettura 
\noun on
ARM
\noun default
 questo non succede.
\end_layout

\begin_layout Standard
Al contrario, vi sono una serie di cartelle per raggruppare l'implementazione
 delle funzioni per piattaforma e per singolo modello, in quanto il modello
 di distribuzione delle specifiche di 
\noun on
ARM
\noun default
 è diverso dal modello di sviluppo intel
\begin_inset LatexCommand citep
key "arm_intel_mobile"

\end_inset


\end_layout

\begin_layout Section
Quale usare
\end_layout

\begin_layout Standard
Poiché vogliamo usare gdb su un 
\noun on
host
\noun default
 x86, ma con 
\noun on
target
\noun default
 
\noun on
ARM
\noun default
, abbiamo bisogno di usare un debugger
\emph on
 compilato per x86
\emph default
, che sappia tracciare le istruzioni ed estrarre i simboli da un binario
 (il kernel)
\emph on
 compilato per 
\noun on
ARM
\emph default
\noun default
.
\end_layout

\begin_layout Standard
Per questo abbiamo scaricato i sorgenti, li abbiamo estratti e compilati,
 facendo attenzione a impostare 
\noun on
--target=arm-linux
\noun default
 nella fase di configurazione per analizzare binari per ARM.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,extendedchars=true,language=bash,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

$ wget http://ftp.gnu.org/gnu/gdb/gdb-6.8.tar.gz
\end_layout

\begin_layout Standard

$ tar xzf gdb-6.8.tar.gz
\end_layout

\begin_layout Standard

$ cd gdb-6.8
\end_layout

\begin_layout Standard

$ ./configure --target=arm-linux
\end_layout

\begin_layout Standard

$ make && su -c 'make install'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alla fine della fase di compilazione, in 
\noun on
/usr/local/bin
\noun default
 (o dovunque sia stato definito il 
\noun on
PREFIX
\noun default
 in fase di configurazione), saranno stati generati i file 
\noun on
arm-linux-gdb
\noun default
 (il debugger vero e proprio), 
\noun on
arm-linux-gdbtui
\noun default
 (frontend semi-grafico) e 
\noun on
arm-linux-run
\noun default
 (simulatore in grado di eseguire i programmi per 
\noun on
ARM
\noun default
 su x86).
\end_layout

\begin_layout Section
Come usarlo
\end_layout

\begin_layout Standard
Usare un debugger per monitorare processi utente è ragionevolmente facile.
 Le cose si complicano parecchio in caso si voglia debuggare il kernel stesso!
 Questo perché l'attività di debugging altro non è che eseguire un processo
 (il debugger) che, tramite chiamate di sistema (ad esempio tipo la funzione
 
\noun on
ptrace
\noun default
()) analizza il comportamento di un altro processo (il programma da controllare).
\end_layout

\begin_layout Standard
Tuttavia nel caso si voglia controllare il kernel, non è possibile avere
 accesso alle chiamate di sistema stesse (visto che riguardano il programma
 da controllare).
\end_layout

\begin_layout Standard
Tuttavia una soluzione esiste.
\end_layout

\begin_layout Standard
\begin_inset Note Shaded
status open

\begin_layout Standard
TROVARE - SCOPIAZZARE immagine debug remoto fatto con qemu!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lavorando con qemu è possibile impostare l'emulatore (che è un programma
 utente, sulla macchina host) per offrire una connessione a gdb.
\end_layout

\begin_layout Standard
Lancio qemu con le opzioni -S -s, e, da un altro terminale, uso
\end_layout

\begin_layout LyX-Code
gdb $PATH/$TO/vmlinux ...
\end_layout

\begin_layout Standard
quindi scrivo il comando
\end_layout

\begin_layout LyX-Code
target remote :1234
\end_layout

\begin_layout Standard
da lì in poi il debug è quello classico :)
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Haret"

\end_inset

Haret
\end_layout

\begin_layout Standard
Haret
\begin_inset LatexCommand citep*
key "haret_home_page"

\end_inset

 è un boot-loader scritto in C/C++ per Windows Mobile®
\begin_inset LatexCommand nomenclature
symbol "Windows Mobile®"
description "Microsoft® Windows Mobile®, sistema operativo concepito per palmari, telefoni cellulari e Pocket PC"

\end_inset


\end_layout

\begin_layout Section
Perché
\end_layout

\begin_layout Standard
Esistono due modi per far partire linux su un comune palmare.
\end_layout

\begin_layout Itemize
Invasivo
\end_layout

\begin_layout Itemize
Non invasivo
\end_layout

\begin_layout Standard
Nel modo invasivo viene modificato la memoria interna del palmare installandoci
 sopra un bootloader universale Uboot il quale permette di far partire kernel
 anche da remoto sin dall'avvio.
 Con questa modalità però si perde tutto il software preinstallato sulla
 macchina dal momento che si sovrascrive la memoria stessa.
\end_layout

\begin_layout Standard
Nel modo non invasivo viene avviato un programma sotto Windows CE (haret)
 per lanciare il kernel dopo aver disabilitato l'hardware in modo da non
 danneggiarlo.
 Questa è, in effetti, una modalità abbastanza utilizzata anche se vi sono
 problemi di compatibilità tra l'hardware e Haret.
 sul wiki di Haret è possibili trovare la lista dei dispositivi testati
 ed in fase di testing.
\end_layout

\begin_layout Section
Dove
\end_layout

\begin_layout Standard
È un programma fatto da un pazzo furioso, nel progetto di handhelds.org,
 ed è un boot-loader implementato come programma per Windows Mobile®
\end_layout

\begin_layout Section
Come
\end_layout

\begin_layout Standard
Il suo obbiettivo è di preparare il dispositivo al lancio del kernel linux.
\end_layout

\begin_layout Standard
Il programma viene copiato all'interno di una scheda di memoria (miniSD)
 con alcuni file di configurazione e il kernel stesso.
 Il file di configurazione startup.txt:
\end_layout

\begin_layout LyX-Code
\begin_inset Include \verbatiminput{startup.txt}
preview false

\end_inset


\end_layout

\begin_layout Standard
indica all'eseguibile haret.exe come settare alcuni parametri (variabili
 globali all'interno del codice di haret) quali KERNEL, MTYPE, INITRD, CMDLINE
 ed infine avvia la funzione (interna al codice di haret quindi scritta
 in C)
\emph on
bootlinux.
\end_layout

\begin_layout Section
Codice
\end_layout

\begin_layout Standard
Il codice del programma prevede parti scritte in C/C++ e parti scritte in
 Assembly.
 Le funzioni più interessanti sono presenti all'interno del file linboot.cpp.
\end_layout

\begin_layout Standard
La funzione
\emph on
launchKernel
\emph default
 ad esempio è responsabile di inibire l'hardware e lanciare il kernel
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily},breaklines=true,language=C"
inline false
status collapsed

\begin_layout Standard

static void
\end_layout

\begin_layout Standard

launchKernel(struct bootmem *bm)
\end_layout

\begin_layout Standard

{
\end_layout

\begin_layout Standard

// Prep the trampoline.
\end_layout

\begin_layout Standard

uint32 physAddrTram = setupTrampoline();
\end_layout

\begin_layout Standard

if (! physAddrTram)
\end_layout

\begin_layout Standard

return;
\end_layout

\begin_layout Standard

// Cache an mmu pointer for the trampoline
\end_layout

\begin_layout Standard

uint8 *virtAddrMmu = memPhysMap(cpuGetMMU());
\end_layout

\begin_layout Standard

Output("MMU setup: mmu=%p/%08x", virtAddrMmu, cpuGetMMU());
\end_layout

\begin_layout Standard

// Call per-arch setup.
\end_layout

\begin_layout Standard

int ret = Mach->preHardwareShutdown();
\end_layout

\begin_layout Standard

if (ret) {
\end_layout

\begin_layout Standard

Output(C_ERROR "Setup for machine shutdown failed");
\end_layout

\begin_layout Standard

return;
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

Screen("Go Go Go...");
\end_layout

\begin_layout Standard

// Disable interrupts
\end_layout

\begin_layout Standard

take_control();
\end_layout

\begin_layout Standard

fb_clear(&bm->pd->fbi);
\end_layout

\begin_layout Standard

fb_printf(&bm->pd->fbi, "HaRET boot
\backslash
nShutting down hardware
\backslash
n");
\end_layout

\begin_layout Standard

// Call per-arch boot prep function.
\end_layout

\begin_layout Standard

Mach->hardwareShutdown(&bm->pd->fbi);
\end_layout

\begin_layout Standard

fb_printf(&bm->pd->fbi, "Turning off MMU...
\backslash
n");
\end_layout

\begin_layout Standard

// Disable MMU and launch linux.
\end_layout

\begin_layout Standard

mmu_trampoline(physAddrTram, virtAddrMmu, bm->physExec, Mach->flushCache);
\end_layout

\begin_layout Standard

// The above should not ever return, but we attempt recovery here.
\end_layout

\begin_layout Standard

return_control();
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
mentre la funzione
\emph on
preloader
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily},breaklines=true,language=C"
inline false
status collapsed

\begin_layout Standard

// Code to launch kernel.
\end_layout

\begin_layout Standard

static void __preload
\end_layout

\begin_layout Standard

preloader(struct preloadData *data)
\end_layout

\begin_layout Standard

{
\end_layout

\begin_layout Standard

    data->fbi.fb = (uint16 *)data->physFB;
\end_layout

\begin_layout Standard

    data->fbi.fonts = (unsigned char *)data->physFonts;
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "In preloader
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    uint32 psr = do_cpuGetPSR();
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "PSR=%%x
\backslash

\backslash
n", psr);
\end_layout

\begin_layout Standard

    if ((psr & 0xc0) != 0xc0)
\end_layout

\begin_layout Standard

        FB_PRINTF(&data->fbi, "ERROR: IRQS not off
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    if (fbOverlaps(data)) {
\end_layout

\begin_layout Standard

        FB_PRINTF(&data->fbi, "Disabling framebuffer feedback
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        data->fbi.fb = 0;
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    // Copy tags to beginning of ram.
\end_layout

\begin_layout Standard

    char *destTags = (char *)data->startRam + PHYSOFFSET_TAGS;
\end_layout

\begin_layout Standard

    do_copy(destTags, data->tags, TAGSIZE);
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "Tags relocated
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    // Copy kernel image
\end_layout

\begin_layout Standard

    char *destKernel = (char *)data->startRam + PHYSOFFSET_KERNEL;
\end_layout

\begin_layout Standard

    int kernelCount = PAGE_ALIGN(data->kernelSize) / PAGE_SIZE;
\end_layout

\begin_layout Standard

    do_copyPages((char *)destKernel, data->indexPages, 0, kernelCount);
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "Kernel relocated
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    // Copy initrd (if applicable)
\end_layout

\begin_layout Standard

    char *destInitrd = (char *)data->startRam + PHYSOFFSET_INITRD;
\end_layout

\begin_layout Standard

    int initrdCount = PAGE_ALIGN(data->initrdSize) / PAGE_SIZE;
\end_layout

\begin_layout Standard

    do_copyPages(destInitrd, data->indexPages, kernelCount, initrdCount);
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "Initrd relocated
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    // Do CRC check (if enabled).
\end_layout

\begin_layout Standard

    if (data->doCRC) {
\end_layout

\begin_layout Standard

        FB_PRINTF(&data->fbi, "Checking tags crc...");
\end_layout

\begin_layout Standard

        uint32 crc = crc32_be(0, destTags, TAGSIZE);
\end_layout

\begin_layout Standard

        crc = crc32_be_finish(crc, TAGSIZE);
\end_layout

\begin_layout Standard

        if (crc == data->tagsCRC)
\end_layout

\begin_layout Standard

            FB_PRINTF(&data->fbi, "okay
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        else
\end_layout

\begin_layout Standard

            FB_PRINTF(&data->fbi, "FAIL FAIL FAIL
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        FB_PRINTF(&data->fbi, "Checking kernel crc...");
\end_layout

\begin_layout Standard

        crc = crc32_be(0, destKernel, data->kernelSize);
\end_layout

\begin_layout Standard

        crc = crc32_be_finish(crc, data->kernelSize);
\end_layout

\begin_layout Standard

        if (crc == data->kernelCRC)
\end_layout

\begin_layout Standard

            FB_PRINTF(&data->fbi, "okay
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        else
\end_layout

\begin_layout Standard

            FB_PRINTF(&data->fbi, "FAIL FAIL FAIL
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        if (data->initrdSize) {
\end_layout

\begin_layout Standard

            FB_PRINTF(&data->fbi, "Checking initrd crc...");
\end_layout

\begin_layout Standard

            crc = crc32_be(0, destInitrd, data->initrdSize);
\end_layout

\begin_layout Standard

            crc = crc32_be_finish(crc, data->initrdSize);
\end_layout

\begin_layout Standard

            if (crc == data->initrdCRC)
\end_layout

\begin_layout Standard

                FB_PRINTF(&data->fbi, "okay
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

            else
\end_layout

\begin_layout Standard

                FB_PRINTF(&data->fbi, "FAIL FAIL FAIL
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

        }
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

    FB_PRINTF(&data->fbi, "Jumping to Kernel...
\backslash

\backslash
n");
\end_layout

\begin_layout Standard

    // Boot
\end_layout

\begin_layout Standard

    typedef void (*lin_t)(uint32 zero, uint32 mach, char *tags);
\end_layout

\begin_layout Standard

    lin_t startfunc = (lin_t)destKernel;
\end_layout

\begin_layout Standard

    startfunc(0, data->machtype, destTags);
\end_layout

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
è sicuramente la più importante dal momento che nelle ultime tre righe passa
 il controllo al kernel terminando l'esecuzione di haret stesso quindi.
\end_layout

\begin_layout LyX-Code
typedef void (*lin_t)(uint32 zero, uint32 mach, char *tags);
\end_layout

\begin_layout Standard
viene definita un prototipo di funzione di tipo puntatore a lin_t
\end_layout

\begin_layout LyX-Code
lin_t startfunc = (lin_t)destKernel;
\end_layout

\begin_layout Standard
è definita una variabile startfunc di tipo lin_t come cast della variabile
 destKernel, buffer di memoria contenente il kernel in ram
\end_layout

\begin_layout LyX-Code
startfunc(0, data->machtype, destTags);
\end_layout

\begin_layout Standard
è lanciata la funzione startfunc con in input uno 0, il valore della variabile
 Mtype passata in precedenza e il valore di destTags, buffer di memoria
 contenenti i tags in ram.
\end_layout

\begin_layout Standard
La programmazione in C/C++ è suddivisa in due fasi dal momento che dopo
 lo shutdown dell'hardware il programma accede direttamente alla memoria
 e non riesce a tradurre le funzioni e librerie tipiche del C con conseguente
 uso di funzion ad-hoc.
 Ad esempio nella funzione preloader vi è
\end_layout

\begin_layout LyX-Code
FB_PRINTF(&data->fbi, "In preloader
\backslash

\backslash
n");
\end_layout

\begin_layout Standard
la quale risulta una macro definita nel codice in modo seguente
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily},breaklines=true"
inline false
status open

\begin_layout Standard

#define STR_IN_CODE(sec,str) ({
\backslash

\end_layout

\begin_layout Standard

    const char *__str;
\backslash

\end_layout

\begin_layout Standard

    asm(".section " #sec ", 1
\backslash
n"
\backslash

\end_layout

\begin_layout Standard

        "1:      .asciz
\backslash
"" str "
\backslash
"
\backslash
n"
\backslash

\end_layout

\begin_layout Standard

        "        .balign 4
\backslash
n"
\backslash

\end_layout

\begin_layout Standard

        "        .section " #sec ", 0
\backslash
n"
\backslash

\end_layout

\begin_layout Standard

        "        add %0, pc, #( 1b - .
 - 8 )
\backslash
n"
\backslash

\end_layout

\begin_layout Standard

        : "=r" (__str));
\backslash

\end_layout

\begin_layout Standard

    __str;
\backslash

\end_layout

\begin_layout Standard

})
\end_layout

\begin_layout Standard

#define FB_PRINTF(fbi,fmt,args...) fb_printf((fbi), STR_IN_CODE(.text.preload,
 fmt) , ##args )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In haret esistono due tipologie di output
\end_layout

\begin_layout Itemize
File di log
\end_layout

\begin_layout Itemize
Stampa a video
\end_layout

\begin_layout Standard
Per abilitare l'output su file di log è necessario creare un file vuoto
 all'interno della cartella dove è presente l'eseguibile haret.exe e rinominarlo
\emph on
earlyharetlog.txt
\emph default
.
 Il file di log haretlog.txt verrà creato nella stessa cartella.
 All'interno del codice la funzione
\emph on
Output
\emph default
 è la responsabile della scrittura su file.
\end_layout

\begin_layout Standard
La seconda tipologia di output si rende necessaria quando avviene lo shutdown
 dell'hardware dal momento che non si ha più accesso alla memoria della
 miniSd.
 All'interno del codice la funzione
\emph on
fb_printf
\emph default
 stampa a video ove previsto.
\end_layout

\begin_layout Standard
Questo rappresenta la parte finale di un file di log.
 Nella prima parte vi è il riconoscimento della macchina da parte del sistema.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily},breaklines=true"
inline false
status open

\begin_layout Standard

Welcome, this is HaRET pre-0.5.2-20080711_124633 running on WindowsCE v5.1
\end_layout

\begin_layout Standard

Minimal virtual address: 00010000, maximal virtual address: 7FFFFFFF
\end_layout

\begin_layout Standard

Detected machine Panda/s3c2442 (Plat='PocketPC' OEM='PAND100')
\end_layout

\begin_layout Standard

CPU is ARM ARM arch 4T stepping 0 running in system mode
\end_layout

\begin_layout Standard

Enter 'HELP' for a short command summary.
\end_layout

\begin_layout Standard

Running WSAStartup
\end_layout

\begin_layout Standard

Starting gui
\end_layout

\begin_layout Standard

In initdialog
\end_layout

\begin_layout Standard

Found machine Panda
\end_layout

\begin_layout Standard

executing startup.txt
\end_layout

\begin_layout Standard

HaRET(1)# set MTYPE 1806
\end_layout

\begin_layout Standard

HaRET(2)# set KERNEL "zImage"
\end_layout

\begin_layout Standard

HaRET(3)# set CMDLINE "root=/dev/mmcblk0p2 console=tty0 mem=128M rootdelay=5"
\end_layout

\begin_layout Standard

HaRET(4)# bootlinux
\end_layout

\begin_layout Standard

boot KERNEL=zImage INITRD=
\end_layout

\begin_layout Standard

Opening file zImage
\end_layout

\begin_layout Standard

boot params: RAMADDR=30000000 RAMSIZE=08000000 MTYPE=1806 CMDLINE='root=/dev/mmc
blk0p2 console=tty0 mem=128M rootdelay=5'
\end_layout

\begin_layout Standard

Boot FB feedback: 1
\end_layout

\begin_layout Standard

Built virtual to physical page mapping
\end_layout

\begin_layout Standard

Allocated 265 pages (tags=4FB00000/36b4e000 kernel=4FB01000/36b4f000 initrd=4FC0
5000/36a47000 index=4FC05000/36a47000)
\end_layout

\begin_layout Standard

Built kernel tags area
\end_layout

\begin_layout Standard

Built page index
\end_layout

\begin_layout Standard

Video buffer at 52800000 sx=240 sy=320 mx=60 my=53
\end_layout

\begin_layout Standard

Video Phys FB=10800000 Fonts=36a45064
\end_layout

\begin_layout Standard

preload=2260@4FC08000/36a44000 sj=4FC08000 stack=4FC06000/36a46000 data=4FC07000
/36a45000 exec=36a44128
\end_layout

\begin_layout Standard

Reading 1062116 bytes...
\end_layout

\begin_layout Standard

Read complete
\end_layout

\begin_layout Standard

Launching to physical address 36a44010
\end_layout

\begin_layout Standard

Trampoline setup (tram=136@00024AEC/1c024aec/30882aec)
\end_layout

\begin_layout Standard

MMU setup: mmu=A0250000/30550000
\end_layout

\begin_layout Standard

Go Go Go...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si noti come al terzo rigo avvisa dell'avvenuto riconoscimento della macchina
 e della tipologia di cpu.
 Poi parte nell'esecuzione del contenuto di
\emph on
startup.txt
\emph default
 come fossero comandi separati tra loro (si noti il carattere # indicatore
 della pseudo-shell).
 L'ultimo comando è appunto
\emph on
bootlinux
\emph default
 il quale fa partire l'esecuzione del codice visto in precedenza.
 Alla fine del file di log vi è la scritta
\emph on
Go Go Go ...

\emph default
 che è l'ultimo messaggio previsto dal codice prima di spegnere l'hardware
 e lasciare l'esecuzione al kernel.
 La presenza di questo messaggio quindi implica il successo nell'esecuzione
 di haret.
 Tutti gli eventuali problemi successivi saranno dovuti al kernel non più
 ad haret.
\end_layout

\begin_layout Section
Problemi
\end_layout

\begin_layout Standard
Abbiamo constatato delle difficoltà a debuggare su un sistema embedded.
\end_layout

\begin_layout Standard
Nel nostro caso avevamo problemi dal momento che ci appariva la scritta
 Go Go Go...
 ma il kernel non partiva.
\end_layout

\begin_layout Standard
Eravamo quindi davanti una serie di possibili cause da dimostrare.
\end_layout

\begin_layout Standard
Il primo dubbio risolto riguardava errori presenti all'interno del codice
 di haret.
 Con un'attento debug tramite stringhe stampate sullo schermo ci siamo accertati
 che effettivamente il controllo passava al kernel (tre righe finali viste
 in precedenza).
\end_layout

\begin_layout Standard
Il dubbio immediatamente successivo riguardava un problema di errato passaggio
 del file del kernel.
\end_layout

\begin_layout Standard
Anche in questo caso abbiamo stampato a video e confrontato bit a bit il
 file del kernel che passavamo all'interno di startup.txt e il contenuto
 del buffer di memoria che veniva avviato da haret.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "bibtotoc,alpha"
bibfiles "web-o-grafia"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand printnomenclature

\end_inset


\end_layout

\end_body
\end_document
