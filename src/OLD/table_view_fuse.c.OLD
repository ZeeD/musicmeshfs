#include "table_view_fuse.h"
#include "utils.h"
#include "fuse_utils.h"

int musicmeshfs_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
        off_t offset, struct fuse_file_info *fi) {
    errprintf("[READDIR] path = `%s'\n", path);
    (void) offset;
    (void) fi;
    filler(buf, ".", NULL, 0);
    filler(buf, "..", NULL, 0);
    if (PATTERN_DIR_NAME.size) {
        dynamic_str_t sottodir = schema_to_dirs(PATTERN_DIR_NAME,
                split(path+1, '/'));
        for (int i=0; i<sottodir.size; i++)
            filler(buf, sottodir.buf[i], NULL, 0);
    }
    return 0;
}

/**
    regola: se path != "/" e non è elencato dalla directory superiore di path,
    ritorna -ENOENT
    \todo: stub, farla davvero!!!
*/
int musicmeshfs_getattr(const char* path, struct stat* filestat) {
    errprintf("[GETATTR] path = `%s'\n", path);
    if (!strcmp(path, "/")) {   // root esiste :)
        memset(filestat, 0, sizeof(struct stat));
        filestat->st_mode = S_IFDIR | 0755;
        filestat->st_nlink = 2;
        return 0;
    }
    dynamic_str_t splitted_path = split(path+1, '/');
    dynamic_str_t sliced_path = slice_str(splitted_path, 0, splitted_path.size-1);
    char* last_element = splitted_path.buf[splitted_path.size-1];

    // devo sapere se l'ultimo elemento di path esiste,
    //      altrimenti ritornare -ENOENT
    // come? controllo se l'"ls" di tutto prima dell'ultimo elemento di path
    //                                        contiene l'ultimo elemento di path

    dynamic_str_t dirs = schema_to_dirs(PATTERN_DIR_NAME, sliced_path);
//     dbgprint_str(dirs, "getattr.dirs");
//     dbgprint_str(splitted_path, "splitted_path");
//     dbgprint_str(sliced_path, "sliced_path");
//     fprintf(stderr, "last_element = `%s'\n", last_element);
    if (!contains_str(dirs, last_element)) { // file non esistente
        free_str(&sliced_path);
        free_str(&splitted_path);
        free_str(&dirs);
        return -ENOENT;
    }
    // file esistente, devo solo decidere se è un file o una directory :)
    memset(filestat, 0, sizeof(struct stat));
    if (is_a_dir(PATTERN_DIR_NAME, splitted_path)) {
        filestat->st_mode = S_IFDIR | 0755;
        filestat->st_nlink = 2;
    }
    else{
        filestat->st_mode = S_IFREG | 0444; // TODO: permessi
        filestat->st_nlink = 1;
        filestat->st_size = get_size(PATTERN_DIR_NAME, splitted_path);
//         fprintf(stderr,
//                 "[DBG]real_path = `%s', virtual_path = `%s'\n",
//                 virtual_path_to_real_path(PATTERN_DIR_NAME, splitted_path),
//                 path);
//         virtual_path_to_real_path(PATTERN_DIR_NAME, splitted_path);
    }
    free_str(&splitted_path);
    return 0;
}

/**
    \todo stub!
*/
int musicmeshfs_rename(const char* from, const char* to) {
    errprintf("[RENAME] from = `%s', to = `%s'\n", from, to);
    dynamic_str_t fissi, dinamici, splitted_to = split(to+1, '/');
    for (int i=0; i<splitted_to.size; i++) {
        calcola_elementi(splitted_to.buf[i], &fissi, &dinamici);
        dbgprint_str(fissi, "RENAME->fissi");
        dbgprint_str(dinamici, "RENAME->dinamici");
    }
    return -1;
}

/**
    \todo stub!
*/
int musicmeshfs_chmod(const char* path, mode_t mode) {
    errprintf("[CHMOD] path = `%s'\n", path);
    (void) mode;
    return -1;
}

/**
    implementazione della callback open di fuse
    \param virtual_path percorso nel file system virtuale di cui è stato
            richiesto il contenuto
    \param ffi informazioni aggiuntive di fuse (in particolare, ffi->fh indica
            il file descriptor del file REALE da aprire)
    \return il valore di ritorno di open(path_REALE, O_RDONLY);
    \sa fuse.h, musicmeshfs_open(), close()
*/
int musicmeshfs_open(const char* virtual_path, struct fuse_file_info* ffi) {
    errprintf("[OPEN] virtual_path = `%s'\t", virtual_path);
    char* real_path = virtual_path_to_real_path(PATTERN_DIR_NAME,
            split(virtual_path+1, '/'));
    errprintf("real_path = `%s'\t", real_path);
    int i = open(real_path, O_RDONLY);
    errprintf("i = %d\n", i);
    if (i == -1)
        return -errno;
    ffi->fh = i;
    return 0;
}

/**
    implementazione della callback release di fuse
    \param virtual_path percorso nel file system virtuale di cui è stato
            richiesto il contenuto
    \param ffi informazioni aggiuntive di fuse (in particolare, ffi->fh indica
            il file descriptor del file REALE da chiudere)
    \return il valore di ritorno di close(ffi->fh);
    \sa fuse.h, musicmeshfs_open(), close()
*/
int musicmeshfs_release(const char* virtual_path, struct fuse_file_info* ffi) {
    errprintf("[RELEASE] path = `%s'\n", virtual_path);
    close(ffi->fh);
    return 0;   // nella doc dice che non è usata
}

/**
    implementazione della callback read di fuse
    \param virtual_path percorso nel file system virtuale di cui è stato
            richiesto il contenuto
    \param buffer vettore su cui scrivere le informazioni richieste
    \param size dimensione del buffer
    \param offset valore di "spiazzamento" da usare per la scrittura su buffer
    \param ffi informazioni aggiuntive di fuse (in particolare, ffi->fh indica
            il file descriptor del file REALE da leggere)
    \return il valore di ritorno di pread(ffi->fh, buffer, size, offset);
    \sa fuse.h, musicmeshfs_open(), pread()
*/
int musicmeshfs_read(const char* virtual_path, char* buffer, size_t size,
            off_t offset, struct fuse_file_info* ffi) {
    errprintf("[READ] path = `%s'\ti = %d\n", virtual_path, (int)ffi->fh);
    int res = pread(ffi->fh, buffer, size, offset);
    if (res == -1)
        res = -errno;
    return res;
}
