#LyX 1.5.5 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\language italian
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
GNU/Linux su ARM tramite qemu
\end_layout

\begin_layout Author
Nicola Corriero
\newline
Vito De Tullio
\end_layout

\begin_layout Chapter
kernel
\end_layout

\begin_layout Section
configurazione
\end_layout

\begin_layout Standard
il .config finale è
\end_layout

\begin_layout Standard
\begin_inset Include \verbatiminput{_CONFIGURE_VANIGLIA_VERSATILE_2.6.25.10}
preview false

\end_inset


\end_layout

\begin_layout Section
output (Image, zImage + compressore)
\end_layout

\begin_layout Standard
Da notare come lanciare
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout Standard
crei una serie di file, in particolare
\end_layout

\begin_layout Description

\family typewriter
Image
\family default
 immagine del kernel, caricata dal bootloader
\end_layout

\begin_layout Description

\family typewriter
zImage
\family default
 immagine del kernel, compressa tramite gzip e preceduta da un decompressore
\end_layout

\begin_layout Description

\family typewriter
bzImage
\family default
 immagine del kernel, compressa tramite gbzip e preceduta da un decompressore
\end_layout

\begin_layout Description

\family typewriter
xipImage
\family default
 immagine del kernel, ??? (boh, non lo so) [solo se abilitato nel kernel]
\end_layout

\begin_layout Description

\family typewriter
vmlinux
\family default
 ???
\end_layout

\begin_layout Section
Avvio
\end_layout

\begin_layout Subsection
Dal click al bios
\end_layout

\begin_layout Standard
C'è poco da dire: fondamentalmente è tutto hardware, quindi 
\emph on
black magic
\emph default
, e, oltretutto, poco interessante.
 In sostanza arriva un segnale al trasformatore dal pulsante, che inizia
 ad alimentare la 
\noun on
cpu
\noun default
, che esegue il programma contenuto in una 
\noun on
rom
\noun default
, 
\noun on
nvram
\noun default
, o 
\noun on
cmos ram
\noun default
.
 Viene lanciato il bios, che ha il compito di verificare alcune funzioni
 fondamentali (che arrivi la corrente alla cpu, alla ram e alle varie periferich
e...) e di eseguire il contenuto dell'
\noun on
mbr.
\end_layout

\begin_layout Subsection
Dal bios al bootloader
\end_layout

\begin_layout Standard
Anche qui c'è poco da dire
\end_layout

\begin_layout Subsection
Dal bootloader a 
\family typewriter
init
\end_layout

\begin_layout Standard
I primi istanti di 
\end_layout

\begin_layout Standard
Il modo più facile per analizzare il comportamento del 
\end_layout

\begin_layout Chapter
Compilatore
\end_layout

\begin_layout Section
Quale
\end_layout

\begin_layout Standard
Per compilare il kernel linux è necessario usare il gcc (cioè, non è che
 è necessario, ma noi quello avevamo).
\end_layout

\begin_layout Section
Cross-compilazione
\end_layout

\begin_layout Standard
Per compilare un kernel per ARM ci sono le seguenti opzioni:
\end_layout

\begin_layout Enumerate
Avere un sistema operativo + compilatore C su architettura ARM (e parecchio
 tempo, data la potenza di questi dispositivi)
\end_layout

\begin_layout Enumerate
\begin_inset LatexCommand label
name "enu:cross-compilare"

\end_inset

Avere un sistema operativo + compilatore C su architettura x86 + istruire
 il compilatore C a generare eseguibili per architettura ARM
\end_layout

\begin_layout Standard
Si è scelto di approcciarsi al problema tramite la soluzione 
\begin_inset LatexCommand ref
reference "enu:cross-compilare"

\end_inset

.
 D'ora innanzi, quindi, si dirà
\end_layout

\begin_layout Description

\noun on
host
\noun default
 la macchina x86 su cui sono presenti compilatore e sorgenti
\end_layout

\begin_layout Description

\noun on
target
\noun default
 la macchina ARM su cui si utilizzerà effettivamente il kernel compilato
\end_layout

\begin_layout Standard
Ciò comporta una serie di vantaggi:
\end_layout

\begin_layout Itemize
Si può utilizzare come sistema 
\noun on
host
\noun default
 un sistema linux già funzionante (nel nostro caso, sono stati utilizzati
 una debian 
\begin_inset Note Greyedout
status open

\begin_layout Standard
QUACCHECCOSA
\end_layout

\end_inset

 e una OpenSuse 10.3)
\end_layout

\begin_layout Itemize
La capacità di calcolo di una macchina 
\noun on
target
\noun default
 è generalmente limitata, mentre le macchine 
\noun on
host
\noun default
 sono molto più potenti (minimizzando i tempi morti in attesa del termine
 della compilazione)
\end_layout

\begin_layout Itemize
...BOH?
\end_layout

\begin_layout Standard
Ovviamente vi è la difficoltà di avere un compilatore C in grado di generare
 eseguibili per la macchina 
\noun on
target
\noun default
.
 Per fortuna questo è offerto da gcc.
 Per abilitare questa 
\emph on
feature
\emph default
, però, è necessario impostare una opzione in fase di compilazione.
\end_layout

\begin_layout Standard
Nello specifico 
\end_layout

\begin_layout Chapter
qemu
\end_layout

\begin_layout Section
Come ottenerlo
\end_layout

\begin_layout Standard
voglio qemu, 
\end_layout

\begin_layout Section
Sistemi emulati
\end_layout

\begin_layout Standard
normalmente userò
\end_layout

\begin_layout LyX-Code
qemu-system-arm -M versatileab ...
\end_layout

\begin_layout Standard
perché qemu non sa ancora emulare l'architettura Samsung S3C2442b (evabé)
\end_layout

\begin_layout Chapter
debugger
\end_layout

\begin_layout Section
A che serve
\end_layout

\begin_layout Standard
A seguire il codice passo passo
\end_layout

\begin_layout Section
Quale usare
\end_layout

\begin_layout Standard
Poiché sto usando gdb su un HOST
\begin_inset Note Shaded
status open

\begin_layout Standard
DA QUALCHE PARTE BISOGNA DEFINIRE HOST E TARGHET CHE SONO!
\end_layout

\end_inset

 x86, ma con TARGET arm, ho bisogno di usare un debugger 
\emph on
compilato per x86
\emph default
, che sappia estrarre i simboli ecc da un binario (il kernel) 
\emph on
per arm
\emph default
.
\end_layout

\begin_layout Standard
Per questo abbiamo scaricato i sorgenti e ricompilato.
\end_layout

\begin_layout Section
Come usarlo
\end_layout

\begin_layout Standard
Lancio qemu con le opzioni -S -s, e, da un altro terminale, uso
\end_layout

\begin_layout LyX-Code
gdb $PATH/$TO/vmlinux ...
\end_layout

\begin_layout Standard
quindi scrivo il comando
\end_layout

\begin_layout LyX-Code
target remote :1234
\end_layout

\begin_layout Standard
da lì in poi il debug è quello classico :)
\end_layout

\begin_layout Chapter
haret
\end_layout

\begin_layout Section
Dove
\end_layout

\begin_layout Standard
È un programma fatto da un pazzo furioso, nel progetto di handhelds.org,
 ed è un boot-loader di 
\end_layout

\begin_layout Section
Come
\end_layout

\end_body
\end_document
