#LyX 1.5.6 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{hyperref}
\end_preamble
\language italian
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
GNU/Linux su ARM tramite qemu
\end_layout

\begin_layout Author
Vito De Tullio 
\hfill
 
\begin_inset ERT
status open

\begin_layout Standard


\backslash
href{mailto:vito.detullio@gmail.com}{vito.detullio@gmail.com}
\end_layout

\end_inset


\newline
Nicola Corriero 
\hfill
 
\begin_inset ERT
status open

\begin_layout Standard


\backslash
href{mailto:ncorriero@uniba.it}{ncorriero@uniba.it}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Kernel
\end_layout

\begin_layout Section
Configurazione
\end_layout

\begin_layout Standard
il .config finale è
\end_layout

\begin_layout Standard
\begin_inset Include \lstinputlisting{_CONFIGURE_VANIGLIA_VERSATILE_2.6.25.10}[basicstyle={\tiny\ttfamily},caption={.config finale utilizzato},captionpos=tb,extendedchars=true,frame=shadowbox,showstringspaces=false]
preview false

\end_inset


\end_layout

\begin_layout Section
Output (Image, zImage + compressore)
\end_layout

\begin_layout Standard
Da notare come lanciare
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout Standard
crei una serie di file, in particolare
\end_layout

\begin_layout Description

\family typewriter
vmlinux
\begin_inset LatexCommand nomenclature
symbol "vmlinux"
description "Eseguibile non compresso e non bootable del kernel."

\end_inset


\family default
 eseguibile 
\emph on
non compresso
\emph default
 e 
\emph on
non bootable
\emph default
 del kernel.
 Usato soprattutto per debug, come vedremo nel capitolo 
\begin_inset LatexCommand vref
reference "cha:Debugger"

\end_inset

.
\end_layout

\begin_layout Description

\family typewriter
Image
\begin_inset LatexCommand nomenclature
symbol "Image"
description "Immagine del kernel effettivamente eseguita"

\end_inset


\family default
 immagine del kernel effettivamente eseguita
\end_layout

\begin_layout Description

\family typewriter
zImage
\begin_inset LatexCommand nomenclature
symbol "zImage"
description "Immagine del kernel compressa preceduta da un decompressore (obsoleta)"

\end_inset


\family default
 immagine del kernel, compressa tramite gzip e preceduta da un decompressore
 (obsoleta)
\end_layout

\begin_layout Description

\family typewriter
\begin_inset LatexCommand nomenclature
symbol "bzImage"
description "Immagine del kernel compressa ed eseguibile, ma composta da tre parti separate"

\end_inset

bzImage\InsetSpace ~

\family default
(
\begin_inset LatexCommand nomenclature
symbol "big zImage"
description "vedi bzImage"

\end_inset

big\InsetSpace ~

\family typewriter
zImage
\family default
) concatenatzione di 
\family typewriter
bootsect.o
\family default
 + 
\family typewriter
setup.o
\family default
 + 
\family typewriter
misc.o
\family default
 + 
\family typewriter
piggy.o
\family default
.
 
\begin_inset LatexCommand citep
key "vmlinuz_definition,vmlinux_zimage"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Graphics
	filename Anatomy-of-bzimage.png
	lyxscale 50
	width 100col%
	height 100pheight%
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Anatomia di bzImage (da en.wikipedia.org)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Section
Avvio
\end_layout

\begin_layout Subsection
Dal click al bios
\end_layout

\begin_layout Standard
C'è poco da dire: fondamentalmente è tutto hardware, quindi 
\emph on
black magic
\emph default
, e, oltretutto, poco interessante.
 In sostanza arriva un segnale al trasformatore dal pulsante, che inizia
 ad alimentare la 
\noun on
cpu
\noun default
, che esegue il programma contenuto in una 
\noun on
rom
\noun default
, 
\noun on
nvram
\noun default
, o 
\noun on
cmos ram
\noun default
.
 Viene lanciato il bios, che ha il compito di verificare alcune funzioni
 fondamentali (che arrivi la corrente alla cpu, alla ram e alle varie periferich
e...) e di eseguire il contenuto dell'
\noun on
mbr.
\end_layout

\begin_layout Subsection
Dal bios al bootloader
\end_layout

\begin_layout Standard
Anche qui c'è poco da dire.
\end_layout

\begin_layout Subsection
Dal bootloader a 
\family typewriter
init
\end_layout

\begin_layout Standard
I primi istanti di 
\end_layout

\begin_layout Standard
Il modo più facile per analizzare il comportamento del kernel è usando un
\end_layout

\begin_layout Chapter
Compilatore
\end_layout

\begin_layout Section
Quale
\end_layout

\begin_layout Standard
Per compilare il kernel linux è necessario usare il gcc (cioè, non è che
 è necessario, ma noi quello avevamo).
\end_layout

\begin_layout Section
Cross-compilazione
\end_layout

\begin_layout Standard
Per compilare un kernel per ARM ci sono le seguenti opzioni:
\end_layout

\begin_layout Enumerate
Avere un sistema operativo + compilatore C su architettura ARM (e parecchio
 tempo, data la potenza di questi dispositivi)
\end_layout

\begin_layout Enumerate
\begin_inset LatexCommand label
name "enu:cross-compilare"

\end_inset

Avere un sistema operativo + compilatore C su architettura x86 + istruire
 il compilatore C a generare eseguibili per architettura ARM
\end_layout

\begin_layout Standard
Si è scelto di approcciarsi al problema tramite la soluzione 
\begin_inset LatexCommand ref
reference "enu:cross-compilare"

\end_inset

.
 D'ora innanzi, quindi, si dirà
\end_layout

\begin_layout Description

\noun on
host
\begin_inset LatexCommand nomenclature
symbol "host"
description "In ambiente di emulazione, la macchina reale che ospita l'emulatore.\\\\In ambiente di cross-compilazione, la macchina che ospita il compilatore.\\\\Vedi: target"

\end_inset


\noun default
 la macchina x86 su cui sono presenti compilatore e sorgenti
\end_layout

\begin_layout Description

\noun on
target
\begin_inset LatexCommand nomenclature
symbol "target"
description "In ambiente di emulazione, la macchina virtuale generata dall'emulatore.\\\\In ambiente di cross-compilazione, la macchina su cui verranno utilizzati i programmi compilati.\\\\Vedi: host"

\end_inset


\noun default
 la macchina ARM su cui si utilizzerà effettivamente il kernel compilato
\end_layout

\begin_layout Standard
Ciò comporta una serie di vantaggi:
\end_layout

\begin_layout Itemize
Si può utilizzare come sistema 
\noun on
host
\noun default
 un sistema linux già funzionante (nel nostro caso, sono stati utilizzati
 una debian 
\begin_inset Note Greyedout
status open

\begin_layout Standard
QUACCHECCOSA
\end_layout

\end_inset

 e una OpenSuse 10.3)
\end_layout

\begin_layout Itemize
La capacità di calcolo di una macchina 
\noun on
target
\noun default
 è generalmente limitata, mentre le macchine 
\noun on
host
\noun default
 sono molto più potenti (minimizzando i tempi morti in attesa del termine
 della compilazione)
\end_layout

\begin_layout Itemize
...BOH?
\end_layout

\begin_layout Standard
Ovviamente vi è la difficoltà di avere un compilatore C in grado di generare
 eseguibili per la macchina 
\noun on
target
\noun default
.
 Per fortuna questo è offerto da gcc.
 Per abilitare questa 
\emph on
feature
\emph default
, però, è necessario impostare una opzione in fase di compilazione.
\end_layout

\begin_layout Standard
Nello specifico è stata utilizzata una versione pre-compilata di gcc da
 
\begin_inset LatexCommand htmlurl
name "handhelds.org"
target "http://www.handhelds.org/download/projects/toolchain/"

\end_inset


\begin_inset LatexCommand citep
key "handhelds_toolchain"

\end_inset

.
\end_layout

\begin_layout Chapter
qemu
\end_layout

\begin_layout Standard
Qemu è un emulatore e virtualizzatore generico e open source.
 Nello specifico è stato usato per emulare un'architettura basata su cpu
 ARM (Versatile 
\noun on
AB
\noun default
 prima, Samsung 
\noun on
S3C2442B
\noun default
 dopo) per semplificare le procedure di testing e debugging del kernel
\end_layout

\begin_layout Section
Come ottenerlo
\end_layout

\begin_layout Standard
Qemu è libero, e già installato nella maggior parte delle distribuzioni.
 La versione da noi usata è stata la 0.9.0 e la 0.9.1.
\end_layout

\begin_layout Standard
Se non è installato, usate il vostro package manager preferito (YaST, apt-get,
 installpkg, smart...).
 Al termine avrete accesso all'applicazione da terminale.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily},captionpos=tb,extendedchars=true,frame=shadowbox,showstringspaces=false"
inline false
status collapsed

\begin_layout Standard

\begin_inset Caption

\begin_layout Standard
Output di 
\noun on
qemu
\noun default
 lanciato senza parametri
\end_layout

\end_inset

$ qemu
\end_layout

\begin_layout Standard

QEMU PC emulator version 0.9.1, Copyright (c) 2003-2008 Fabrice Bellard
\end_layout

\begin_layout Standard

usage: qemu [options] [disk_image]
\end_layout

\begin_layout Standard

'disk_image' is a raw hard image image for IDE hard disk 0
\end_layout

\begin_layout Standard

Standard options:
\end_layout

\begin_layout Standard

-M machine      select emulated machine (-M ? for list)
\end_layout

\begin_layout Standard

-cpu cpu        select CPU (-cpu ? for list)
\end_layout

\begin_layout Standard

-fda/-fdb file  use 'file' as floppy disk 0/1 image
\end_layout

\begin_layout Standard

-hda/-hdb file  use 'file' as IDE hard disk 0/1 image
\end_layout

\begin_layout Standard

-hdc/-hdd file  use 'file' as IDE hard disk 2/3 image
\end_layout

\begin_layout Standard

-cdrom file     use 'file' as IDE cdrom image (cdrom is ide1 master)
\end_layout

\begin_layout Standard

-drive [file=file][,if=type][,bus=n][,unit=m][,media=d][index=i]
\end_layout

\begin_layout Standard

       [,cyls=c,heads=h,secs=s[,trans=t]][snapshot=on|off]       [,cache=on|off]
\end_layout

\begin_layout Standard

                use 'file' as a drive image
\end_layout

\begin_layout Standard

-mtdblock file  use 'file' as on-board Flash memory image
\end_layout

\begin_layout Standard

-sd file        use 'file' as SecureDigital card image
\end_layout

\begin_layout Standard

-pflash file    use 'file' as a parallel flash image
\end_layout

\begin_layout Standard

-boot [a|c|d|n] boot on floppy (a), hard disk (c), CD-ROM (d), or network
 (n)
\end_layout

\begin_layout Standard

-snapshot       write to temporary files instead of disk image files
\end_layout

\begin_layout Standard

-no-frame       open SDL window without a frame and window decorations
\end_layout

\begin_layout Standard

-alt-grab       use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt)
\end_layout

\begin_layout Standard

-no-quit        disable SDL window close capability
\end_layout

\begin_layout Standard

-no-fd-bootchk  disable boot signature checking for floppy disks
\end_layout

\begin_layout Standard

-m megs         set virtual RAM size to megs MB [default=128]
\end_layout

\begin_layout Standard

-smp n          set the number of CPUs to 'n' [default=1]
\end_layout

\begin_layout Standard

-nographic      disable graphical output and redirect serial I/Os to console
\end_layout

\begin_layout Standard

-portrait       rotate graphical output 90 deg left (only PXA LCD)
\end_layout

\begin_layout Standard

-k language     use keyboard layout (for example "fr" for French)
\end_layout

\begin_layout Standard

-audio-help     print list of audio drivers and their options
\end_layout

\begin_layout Standard

-soundhw c1,...
 enable audio support
\end_layout

\begin_layout Standard

                and only specified sound cards (comma separated list)
\end_layout

\begin_layout Standard

                use -soundhw ? to get the list of supported cards
\end_layout

\begin_layout Standard

                use -soundhw all to enable all of them
\end_layout

\begin_layout Standard

-localtime      set the real time clock to local time [default=utc]
\end_layout

\begin_layout Standard

-full-screen    start in full screen
\end_layout

\begin_layout Standard

-win2k-hack     use it when installing Windows 2000 to avoid a disk full
 bug
\end_layout

\begin_layout Standard

-usb            enable the USB driver (will be the default soon)
\end_layout

\begin_layout Standard

-usbdevice name add the host or guest USB device 'name'
\end_layout

\begin_layout Standard

-name string    set the name of the guest
\end_layout

\begin_layout Standard

Network options:
\end_layout

\begin_layout Standard

-net nic[,vlan=n][,macaddr=addr][,model=type]
\end_layout

\begin_layout Standard

                create a new Network Interface Card and connect it to VLAN
 'n'
\end_layout

\begin_layout Standard

-net user[,vlan=n][,hostname=host]
\end_layout

\begin_layout Standard

                connect the user mode network stack to VLAN 'n' and send
\end_layout

\begin_layout Standard

                hostname 'host' to DHCP clients
\end_layout

\begin_layout Standard

-net tap[,vlan=n][,fd=h][,ifname=name][,script=file][,downscript=dfile]
\end_layout

\begin_layout Standard

                connect the host TAP network interface to VLAN 'n' and use
 the
\end_layout

\begin_layout Standard

                network scripts 'file' (default=/etc/qemu-ifup)
\end_layout

\begin_layout Standard

                and 'dfile' (default=/etc/qemu-ifdown);
\end_layout

\begin_layout Standard

                use '[down]script=no' to disable script execution;
\end_layout

\begin_layout Standard

                use 'fd=h' to connect to an already opened TAP interface
\end_layout

\begin_layout Standard

-net socket[,vlan=n][,fd=h][,listen=[host]:port][,connect=host:port]
\end_layout

\begin_layout Standard

                connect the vlan 'n' to another VLAN using a socket connection
\end_layout

\begin_layout Standard

-net socket[,vlan=n][,fd=h][,mcast=maddr:port]
\end_layout

\begin_layout Standard

                connect the vlan 'n' to multicast maddr and port
\end_layout

\begin_layout Standard

-net none       use it alone to have zero network devices; if no -net option
\end_layout

\begin_layout Standard

                is provided, the default is '-net nic -net user'
\end_layout

\begin_layout Standard

-tftp dir       allow tftp access to files in dir [-net user]
\end_layout

\begin_layout Standard

-bootp file     advertise file in BOOTP replies
\end_layout

\begin_layout Standard

-smb dir        allow SMB access to files in 'dir' [-net user]
\end_layout

\begin_layout Standard

-redir [tcp|udp]:host-port:[guest-host]:guest-port
\end_layout

\begin_layout Standard

                redirect TCP or UDP connections from host to guest [-net
 user]
\end_layout

\begin_layout Standard

Linux boot specific:
\end_layout

\begin_layout Standard

-kernel bzImage use 'bzImage' as kernel image
\end_layout

\begin_layout Standard

-append cmdline use 'cmdline' as kernel command line
\end_layout

\begin_layout Standard

-initrd file    use 'file' as initial ram disk
\end_layout

\begin_layout Standard

Debug/Expert options:
\end_layout

\begin_layout Standard

-monitor dev    redirect the monitor to char device 'dev'
\end_layout

\begin_layout Standard

-serial dev     redirect the serial port to char device 'dev'
\end_layout

\begin_layout Standard

-parallel dev   redirect the parallel port to char device 'dev'
\end_layout

\begin_layout Standard

-pidfile file   Write PID to 'file'
\end_layout

\begin_layout Standard

-S              freeze CPU at startup (use 'c' to start execution)
\end_layout

\begin_layout Standard

-s              wait gdb connection to port
\end_layout

\begin_layout Standard

-p port         set gdb connection port [default=1234]
\end_layout

\begin_layout Standard

-d item1,...
    output log to /tmp/qemu.log (use -d ? for a list of log items)
\end_layout

\begin_layout Standard

-hdachs c,h,s[,t]  force hard disk 0 physical geometry and the optional
 BIOS
\end_layout

\begin_layout Standard

                translation (t=none or lba) (usually qemu can guess them)
\end_layout

\begin_layout Standard

-L path         set the directory for the BIOS, VGA BIOS and keymaps
\end_layout

\begin_layout Standard

-kernel-kqemu   enable KQEMU full virtualization (default is user mode only)
\end_layout

\begin_layout Standard

-no-kqemu       disable KQEMU kernel module usage
\end_layout

\begin_layout Standard

-std-vga        simulate a standard VGA card with VESA Bochs Extensions
\end_layout

\begin_layout Standard

                (default is CL-GD5446 PCI VGA)
\end_layout

\begin_layout Standard

-no-acpi        disable ACPI
\end_layout

\begin_layout Standard

-no-reboot      exit instead of rebooting
\end_layout

\begin_layout Standard

-loadvm file    start right away with a saved state (loadvm in monitor)
\end_layout

\begin_layout Standard

-vnc display    start a VNC server on display
\end_layout

\begin_layout Standard

-daemonize      daemonize QEMU after initializing
\end_layout

\begin_layout Standard

-option-rom rom load a file, rom, into the option ROM space
\end_layout

\begin_layout Standard

-clock          force the use of the given methods for timer alarm.
\end_layout

\begin_layout Standard

                To see what timers are available use -clock help
\end_layout

\begin_layout Standard

During emulation, the following keys are useful:
\end_layout

\begin_layout Standard

ctrl-alt-f      toggle full screen
\end_layout

\begin_layout Standard

ctrl-alt-n      switch to virtual console 'n'
\end_layout

\begin_layout Standard

ctrl-alt        toggle mouse and keyboard grab
\end_layout

\begin_layout Standard

When using -nographic, press 'ctrl-a h' to get some help.
\end_layout

\begin_layout Standard

$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per poter emulare anche il chip Samsung 
\noun on
S3C2442B
\noun default
 è stata utilizzata anche una versione di qemu 
\emph on
custom
\emph default
 modificata e manutenuta dagli sviluppatori del progetto openmoko
\begin_inset LatexCommand citep
key "openmoko_under_qemu"

\end_inset


\end_layout

\begin_layout Section
Sistemi emulati
\end_layout

\begin_layout LyX-Code
qemu-system-arm -M versatileab ...
\end_layout

\begin_layout Standard
perché qemu non sa ancora emulare l'architettura Samsung S3C2442b (evabé)
 
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Debugger"

\end_inset

Debugger
\end_layout

\begin_layout Standard
Poiché abbiamo avuto problemi a far partire il kernel di linux sul dispositivo
 palmare, abbiamo cercato di trovare un modo per avere feedback sull'esecuzione
 del codice e sugli eventuali errori riscontrati sulla piattaforma.
\end_layout

\begin_layout Standard
Poiché vorremmo analizzare il comportamento di un kernel, però, non è possibile
 utilizzare lo stdout / stderr come canali di comunicazione, né loggare
 il comportamento su file, in quanto non è ancora disponibile un'interfaccia
 verso queste strutture ad alto livello.
\end_layout

\begin_layout Standard
Per questo motivo abbiamo considerato l'idea di usare un debugger.
 Per poterla applicare, però, avremmo avuto bisogno di un eseguibile per
 il sistema operativo Windows Mobile® che si integrasse con haret (vedi
 capitolo 
\begin_inset LatexCommand vref
reference "cha:Haret"

\end_inset

).
 L'alternativa scelta è stata quella di usare un emulatore per l'architettura,
 e di usare il classico gdb per il debug.
\end_layout

\begin_layout Standard
Questa scelta ha semplificato l'analisi e il debug dell'esecuzione delle
 singole istruzioni del codice.
\end_layout

\begin_layout Section
A che serve
\end_layout

\begin_layout Standard
Usare un debugger col kernel è stato utile soprattutto per scoprire 
\begin_inset Quotes eld
\end_inset

qual è la prima funzione invocata
\begin_inset Quotes erd
\end_inset

 dal kernel stesso.
\end_layout

\begin_layout Standard
Su architettura x86, infatti, vi è la funzione 
\family typewriter
main.c
\family default
 in 
\family typewriter
$KERNEL_SRC/arch/x86/boot/main.c
\family default
 che identifica la prima funzione invocata, su architettura arm questo non
 succede.
 Al contrario vi sono una serie di cartelle per raggruppare l'implementazione
 delle funzioni per piattaforma e per singolo modello, in quanto il modello
 di arm è diverso dal modello di intel
\begin_inset LatexCommand citep
key "arm_intel_mobile"

\end_inset


\end_layout

\begin_layout Section
Quale usare
\end_layout

\begin_layout Standard
Poiché sto usando gdb su un HOST x86, ma con TARGET arm, ho bisogno di usare
 un debugger 
\emph on
compilato per x86
\emph default
, che sappia estrarre i simboli ecc da un binario (il kernel) 
\emph on
per arm
\emph default
.
\end_layout

\begin_layout Standard
Per questo abbiamo scaricato i sorgenti e ricompilato.
\end_layout

\begin_layout Section
Come usarlo
\end_layout

\begin_layout Standard
Lancio qemu con le opzioni -S -s, e, da un altro terminale, uso
\end_layout

\begin_layout LyX-Code
gdb $PATH/$TO/vmlinux ...
\end_layout

\begin_layout Standard
quindi scrivo il comando
\end_layout

\begin_layout LyX-Code
target remote :1234
\end_layout

\begin_layout Standard
da lì in poi il debug è quello classico :)
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Haret"

\end_inset

Haret
\end_layout

\begin_layout Standard
Haret
\begin_inset LatexCommand citep*
key "haret_home_page"

\end_inset

 è un boot-loader scritto in c per Windows Mobile®
\begin_inset LatexCommand nomenclature
symbol "Windows Mobile®"
description "Microsoft® Windows Mobile®, sistema operativo concepito per palmari, telefoni cellulari e Pocket PC"

\end_inset


\end_layout

\begin_layout Section
Dove
\end_layout

\begin_layout Standard
È un programma fatto da un pazzo furioso, nel progetto di handhelds.org,
 ed è un boot-loader implementato come programma per Windows Mobile®
\end_layout

\begin_layout Section
Come
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "bibtotoc,alpha"
bibfiles "web-o-grafia"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand printnomenclature

\end_inset


\end_layout

\end_body
\end_document
